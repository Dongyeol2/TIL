# STP(Spanning Tree Protocol)

## STP(Spanning Tree Protocol) - IEEE 802.1d

### Spaaning Tree Protocol이란 무엇이며, 왜 필요한가?

> Spanning Tree Protocol(스패닝 트리 프로토콜)은 래디아 펄먼이 고안한 알고리즘에 기반한 OSI 2계층 프로토콜로 랜에서 루프 발생을 방지하기 위해 사용된다.
>
> 출처 : 위치백과 

**Spanning Tree Protocol**(이하 스패닝 트리 프로토콜)은 이더넷 프레임을 주고 받는 계층인 OSI 2계층의 프로토콜로 루프 발생 방지를 위해 만들어졌다. 루프가 발생할 수 밖에 없는 구조에서는 반드시 스패닝 트리 프로토콜을 활성화시켜야 하며 Cisco에서 생산되는 스위치들은 기본적으로 스패닝 트리 프로토콜이 활성화 되어있다. 그리고 각 VLAN 마다 루프가 발생하는 것을 막기 위해 VLAN마다 스패닝 트리 프로토콜을 활성화 시키게 되는데, 이를 **PVST(Per VLAN Spanning Tree)** 라고 부른다. Cisco 고유의 프로토콜이다.

스패닝 트리 프로토콜을 통해 실현하고자 하는 궁극적인 목표는 **루프 발생 차단**이다. 이를 실현하기 위해 스위치들은 자신들이 갖고 있는 인터페이스 중 하나를 **Block(이하 블락)** 시키고자 협상을 한다. 그래야 이더넷 프레임이 끊임없이 돌지 않고 차단된 인터페이스에서 막히게 된다. (하지만 자신의 인터페이스를 막고 싶은 스위치는 없다. 사람도 공동체의 이익을 위해 협상을 벌일 때 자신이 손해보지 않기를 바라듯이 스위치 또한 자신의 인터페이스를 막고싶어하지 않는다. 그래서 스위치간 협상을 벌이게 된다.)

![image](https://user-images.githubusercontent.com/50439622/147025231-7fcfad71-009c-425e-8ecb-d4f478365c9c.png)

스패닝 트리 프로토콜의 협상 과정은 크게 두개로 나눌 수 있다. **Root Switch 선정**과 **Port 선정**이 바로 그것이다.

```
1. Root Switch, Non Root Switch 선출
2. Root / Designated / Alternated Port 선출
```

인터페이스를 차단하려면 어떤 스위치의 인터페이스를 차단해야 할지 정해야 한다. 그래서 먼저 가장 힘센 스위치(?)를 정해야 한다. 이를 **Root Switch(이하 루트 스위치)** 라 하며 루트 스위치는 인터페이스를 블락하지 않아도 된다. 루트 스위치로 선정되지 못한 스위치들은 이 루트 스위치를 바라보며 자신이 루트 스위치와 얼마나 가까운지 경쟁한다. 루트 스위치와의 친분이 가장 적은(?) 스위치는 인터페이스를 블락해야 하는 불행을 겪어야 한다.

스위치의 서열이 정해지고 나면 이번엔 스위치 인터페이스의 서열을 정해야 한다. 스위치마다 어떤 인터페이스가 루트 스위치에 가장 가까운지 경쟁한다. 그리고 가장 경쟁력이 떨어지는 스위치의 가장 경쟁력이 떨어지는 포트가 결국 블락될 운명에 놓인다. 루트 스위치와 가장 가까운 포트를 **Root Port(이하 루트 포트)**, 차단될 운명에 놓인 포트를 **Alternated Port(이하 블락 포트)** 그리고 그 이외의 포트를 **Designated Port(이하 지정 포트)** 라 한다.

![image](https://user-images.githubusercontent.com/50439622/147026003-2cd6bb90-d25f-4481-b081-7676151b3908.png)

이 일련의 과정을 거치면 순환 구조가 사라지고 더 이상 이더넷 프레임이 빙빙 돌지 않게 된다. 스패닝 트리 프로토콜의 궁극적인 목적을 달성하는 것이다.

#### 정리 & Next Step

```
동작 과정 1 > Root Switch, Non Root Switch 선출
동작 과정 2 > Root / Designated / Alternated Port(이하 루트 / 지정 / 블락 포트) 선출
```

먼저 동작 과정 1에 해당하는 스패닝 트리 구조 내에서 Root Switch(이하 루트 스위치)로 선정될 스위치를 찾는다. 루트 스위치는 스패닝 트리 구조에서 구심점 역할을 하며 모든 Non Root Switch(이하 일반 스위치)들은 루트 스위치를 바라보고 가장 가까운 경로를 탐색한다. 스위치 간의 역할이 정리되면 동작 과정 2에 따라 일반 스위치들은 루트 스위치로 향하는 가장 가까운 경로에 있는 포트를 루트 포트로 선정하고 루트 포트의 반대 포트를 지정 포트로 지정해 데이터 이동을 가능케 한다. 그리고 루트 포트도, 지정 포트도 아닌 포트는 결국 일반 데이터 이동이 차단되는 블락 포트가 된다.

이 과정에 대해 자세히 알아보기 위해서 **Bridge Protocol Data Unit(BPDU)** 에 대해 알아야 한다.

### Bridge Protocol Data Unit(BPDU)

Bridge Protocol Data Unit(BPDU)는 루프 없는 구성, 스패닝 트리를 구성할 때 사용하는 이더넷 프레임이다. 즉, 스위치들 간의 대화 수단이다. 스위치들은 BPDU를 주고받으며 서로의 우선순위를 확인하고 루트 스위치를 결정한다. 이를 **Configuration BPDU**라고 한다. 또한 스위치 장애 혹은 스위치 간 링크 장애 발생으로 인해 네트워크에 변화가 생기면 루트 스위치에게 보고하는 경우에도 BPDU가 사용되는데 이를 **TCN(Topology Change Notification) BPDU**라고 한다.

그 중 Configuration BPDU(이하 설정 BPDU)의 구성을 보면 다음과 같다.

![image](https://user-images.githubusercontent.com/50439622/147033988-4d19b101-ae7a-4edb-972b-e10b58878a93.png)

설정 BPDU를 구성하는 다양한 정보들이 보인다. Root Bridge ID, Path Cost, Port ID 등 경로 구성에 중요한 역할을 하는 요소들이 보인다. 그 중에서 우리가 주목해야 할 것은 '**Bridge ID**'이다. Bridge ID(이하 브릿지 ID)는 각 스위치가 갖는 일련의 숫자로 스패닝 트리를 구성하고자 하는 스위치들은 이 브리지 ID의 값 크기를 비교하여 서열을 정한다. 값은 0 ~ 32768 이며 **값이 작을 수록** 더 높은 우선순위(서열)을 갖게 된다. 이 숫자는 사용자가 임의로 지정할 수 있다. 브릿지 ID를 다시 자세히 들여다보면 다음과 같이 구성된다.

![image](https://user-images.githubusercontent.com/50439622/147034263-0b02439f-2ee5-48f7-8524-a17236bf06e9.png)

'MAC 주소'는 스위치의 MAC 주소를 의미한다. 그리고 '우선 순위'는 위에서 언급한 숫자인 **0 ~ 32768**과 **VLAN 번호**를 더한 값이다. 이 두 개 값을 이용하여 브릿지 ID를 생성한다. 우선 순위에 VLAN 번호를 추가로 부여하는 이유는 VLAN별로 스패닝 트리를 구성하는 PVST(Per VLAN Spanning Tree)를 실현하기 위함이다. VLAN 번호가 없다면 모든 VLAN이 다 같은 우선순위 값을 가질 수 밖에 없을 테니 VLAN 별로 우선순위를 줄 수 없어 매우 곤란해 질 수 있다. VLAN 10번의 우선순위만 바꾸고 싶은데 VLAN 20, 30의 우선순위도 함께 바뀔 테니 말이다.

스패닝 트리 프로토콜이 동작하기 위한 중요한 요소들을 살펴 보았으니 본격적으로 스패닝 트리 프로토콜이 동작하는 과정을 살펴보도록 하자

### 동작 과정 1 > Root Switch(Root Bridge)와 Non Root Switch(Non Root Bridge) 선출

스패닝 트리 프로토콜 동작 과정에서 눈여겨볼 특이점은 **루트 스위치를 중심으로 연결되는 스위치들이 뿌리처럼 뻗어나가는 구조를 취한다는 것이다** 스위치가 추적되면 될 수록 Root Bridge(이하 루트 브릿지)가 아닌 Non Root Bridge(이하 일반 스위치)들은 모두 루트 스위치를 바라보게 된다. 마치 나무의 뿌리 모양처럼 말이다. 그래야만 루트 브릿지(루트 스위치)를 필두로 스위치 간 서열을 정리하고 인터페이스를 차단할 스위치를 정할 수 있다. 그러므로 먼저 루트 브릿지를 선출하는 과정을 살펴보자.

앞서 말한 것처럼 스위치의 서열을 정하는 것은 **Bridge ID**이다. 스위치들은 BPDU 프레임을 주고 받으며 브릿지 ID를 확인하고 누구의 서열이 더 높은지 판단한다.

![image](https://user-images.githubusercontent.com/50439622/147037045-e6d250bd-df86-4fbd-afac-4ea8c50d0fc8.png)

위 그림에서 스위치들의 브릿지 ID를 확인할 수 있다. 좌측 상단의 브릿지 ID가 가장 높고 우측하단의 스위치의 브릿지 ID가 가장 낮다. 스위치들이 연결되고 스패닝 트리 프로토콜이 동작하기 시작하면 모든 스위치들은 자신이 루트 스위치라고 주장하며 BPDU를 보내기 시작한다. 그러다 자신보다 더 높은 브릿지 ID가 담긴 BPDU를 전달받으면 더 이상 루트 브릿지임을 주장하지 않고 BPDU 프레임에 자신이 받은 가장 높은 브릿지 ID를 '**Root Bridge ID(이하 루트 브릿지 ID)**'에 담아 다른 스위치들에게 전달한다. 자신보다 높은 브릿지 ID가 담긴 BPDU 프레임을 받아든 스위치들 또한 더 이상 루트 브릿지임을 주장하지 않고 일반 스위치로서 움직인다.

![image](https://user-images.githubusercontent.com/50439622/147037060-8cdf5cfd-bc0b-4899-9920-441018db0983.png)

좌측 상단의 스위치의 브릿지 ID가 가장 높기 때문에 루트 브릿지로 선정된다. 그리고 인접한 스위치들은 루트 브릿지를 인정하고 루트 브릿지만을 바라보게 된다. 이 인접한 스위치들에 연결되는 스위치들 또한 루트 브릿지보다 브릿지 ID가 높지 않다면 마찬가지로 루트 브릿지를 바라보게 된다. 루트 브릿지가 선정되었고 스위치간 서열이 정해졌으니 이제 차단할 포트를 찾는 일이 남았다.

### 동작 과정 2 > Root / Designated / Alternated Port 선출

브릿지 ID를 통해 스위치의 서열을 정했으니 이번엔 각 스위치들의 포트의 서열을 매긴다. **이 서열은 스위치 내에서만 적용되며 다른 스위치와 경합하는 것이 아니다.** 하지만 포트의 서열 또한 루트 브릿지까지의 거리가 얼마나 가까운 지를 경쟁하는 것이기 때문에 루트 브릿지의 영향에서 벗어날 수 없다. 그 전에 기억해야 할 요소가 두 가지 있으니 바로 '**Segment(이하 세그먼트)**'와 '**Path Cost(이하 경로값)**'이다.

![image](https://user-images.githubusercontent.com/50439622/147037069-2bb0d521-58cd-407f-9bb7-9b2d52c2aa7f.png)

세그먼트는 연결된 네트워크 장비간의 연결을 뜻한다. 위 그림에서는 총 4개의 세그먼트를 확인할 수 있다.(장비간 연결이 4개 이기 때문). 세그먼트가 중요한 이유는 아래 한 가지 규칙 때문이다. 스패닝 트리 구조 내에서 어느 포트가 어떤 역할을 맡아야 할 지 헷갈릴 때 아래 규칙을 기억하면 쉽다.

> 하나의 세그먼트에는 반드시 하나의 지정 포트가 있어야 한다.

Path Cost(이하 경로값)은 포트에 적용된 속도를 값으로 변환한 것으로 속도에 대한 적용값은 다음과 같다.

|     속도 (bandwidth)     | 경로값 (path cost) |
| :----------------------: | :----------------: |
|     10 Mbps (이더넷)     |        100         |
| 100 Mbps(패스트 이더넷)  |         19         |
| 1 Gbps (기가비트 이더넷) |         4          |
| 10 Gbps (10 기가 이더넷) |         2          |

스위치와 스위치가 연결되면 Speed와 Duplex에 대해 협상을 하고 서로 동일한 Speed와 Duplex를 갖게 되는데 바로 스위치의 포트에 설정된 속도가 표에서의 속도 (Bandwidth)이다. 그리고 속도마다 다른 경로 값을 부여하고 이를 스패닝 트리 구성에 활용한다. 다시 말해 스위치 자신의 경로값과 루트 브릿지까지의 경로에 위치한 스위치의 경로값을 모두 고려한다. **루트 브릿지로 향하는 경로의 경로값을 모두 더해 가장 작은 값이 나오는 경로를 택하는 것이다.** 아래 그림에서 포트에 설정된 경로값을 확인 할 수 있다.

![image](https://user-images.githubusercontent.com/50439622/147037073-92bfdb58-9a15-434f-8944-9eb3d1ad8e3b.png)

브릿지 ID가 4096인 스위치는 루트 브릿지로 향하는 세그먼트가 하나뿐이며 경로값은 19이다. 브릿지 ID가 8192인 스위치는 두 개의 경로가 있으며 하나는 경로값이 38(19 + 19), 하나는 경로값이 119(100 + 19)이다. 경로가 두 개인데 한 쪽 경로의 값이 훨씬 작으니 스위치는 작은 경로값의 세그먼트를 통신경로로 사용할 것이 분명하다. 세그먼트와 경로값에 대해 알아보았으니 이제 본격적으로 포트를 선출하는 순서에 대해 알아보자.

#### Root Port 선출

스패닝 트리의 구성은 나무 뿌리와 같다고 할 수 있다. 가장 중요한 나무 뿌리인 루트 브릿지로 향하는 가장 가까운 포트가 먼저 선출되며 이를 루트 포트라고 한다. 데이터와 BPDU 프레임이 이동하는 포트이다. 루트 포트를 선출하는 기준은 다음과 같다.

> 1. 가장 작은 경로값을 가지는 포트
> 2. 인접한 스위치의 브릿지 ID가 가장 낮은 포트
> 3. 인접한 스위치의 포트 ID가 가장 낮은 포트(포트 ID : 포트 번호)

위의 기준을 적용해 보면 스위치들의 루트 포트는 다음과 같이 정해진자. 먼저 브릿지 ID가 4096인 스위치들은 **첫번째 기준**에 의거 루트 스위치로 향하는 경로값이 가장 적은 포트(경로값 : 19)를 루트 포트로 정하게 된다. 첫번째 기준을 충족했기 때문에 두번째, 세번째 기준을 볼 필요가 없다.

브릿지 ID가 8192인 스위치는 왼쪽으로 향하는 경로가 경로값이 훨씬 작기 때문에 왼쪽 포트(경로값 38)를 루트 포트로 선택한다. 만약 경로값이 양쪽 모두 같았다면? **두번째 기준**인 브릿지 ID가 가장 낮은 스위치를 접한 포트를 선택한다. 하지만 아래 그림을 보시다시피 인접한 스위치들은 모두 같은 브릿지 ID 값을 갖는다. 그럼 두번째 기준 또한 적용되지 않을 것이다. 그럼 **세번째 기준**을 적용한다. 인접한 스위치 모두 포트 번호가 2번 이라고 가정하면 결국 이 기준 또한 적용되지 않는다. 마지막으로 스위치는 자신의 포트 번호를 보고 가장 낮은 포트 번호(숫자가 작을수록 낮은 포트)를 루트 포트로 택하게 된다.

![image](https://user-images.githubusercontent.com/50439622/147038015-a5d3c766-facf-4005-89f8-c8d288cdeeb1.png)

#### Designated Port 선출

지정 포트는 루트 포트, 블락 포트가 아닌 포트를 이르는 말이다. 단순 포워딩 포트라고 봐도 무방하다. 데이터와 BPDU 프레임을 전송하는 포트이다. 지정 포트를 선출하기 위한 규칙은 루트 포트를 선출하는 규칙과 거의 동일하다. 블락 포트가 아닌 지정 포트를 먼저 선출하는 이유는 루트 포트와 지정 포트가 아닌 포트가 블락 포트로 지정되기 때문이다.

> 1. 가장 작은 경로값을 가지는 포트
> 2. 스위치의 브릿지 ID가 가장 낮은 포트
> 3. 스위치의 포트 ID가 가장 낮은 포트(포트 ID : 포트 번호)

하지만 이런 규칙들은 포트 선출 과정을 이해하기 어렵게 만들 뿐이다. 때문에 위에서 언급한 규칙 한가지를 활용하여 포트 선출과정을 보도록 하자

> 하나의 세그먼트에는 반드시 하나의 지정 포트가 있어야 한다.

세그먼트 하나에는 지정 포트가 하나씩 반드시 있어야 한다는 암묵적인(?) 규칙이 있다. 스위치가 실제 포트 선출에 있어 사용하는 규칙이라기보다 포트를 지정하는 과정에 나타나는 특징이다. 스패닝 트리 프로토콜 동작과정을 이해하는데 이게 좀 더 나은 것 같아 먼저 적용해보자. 아래 루트 포트가 존재하는 세그먼트에 빈 자리가 남아 있는 곳은 모두 지정 포트로 채웠다. 하나의 세그먼트에는 하나의 지정 포트가 반드시 존재해야 하기 때문이다.

![image](https://user-images.githubusercontent.com/50439622/147041424-6ec468df-2502-4601-8dfb-01aac9f197b5.png)

이제 포트가 지정되지 않은, 마지막으로 남은 세그먼트를 살펴보자.

#### Alternated Port 선출

블락 포트는 루트 포트도, 지정 포트도 아닌 포트로 데이터 통신을 하지 않는 포트이다. 그러나 BPDU는 수신한다. 블락 포트가 BPDU를 제외한 모든 트래픽을 송수신하지 않음으로써 루프가 도는 것을 방지한다. 아래 그림에서 남은 하나의 세그먼트에서 블락 포트를 지정해야 한다.

![image](https://user-images.githubusercontent.com/50439622/147046326-b9a72924-534e-4582-823d-cc07168d3ec3.png)

지정 포트 선출과정에서 하나의 세그먼트에는 반드시 하나의 지정 포트가 있어야 한다 말했다. 그렇다는건 위 세그먼트에서 두 포트 중 하나는 지정 포트가 되어야 하고 남은 하나의 포트가 블락 포트가 되어야 함을 의미한다. 바로 여기서 지정 포트 선출 기준이 사용된다.

> 1. 가장 작은 경로값을 가지는 포트
> 2. 스위치의 브릿지 ID가 가장 낮은 포트
> 3. 스위치의 포트 ID가 가장 낮은 포트(포트 ID : 포트 번호)

위의 그림에서는 1번으로 인해 브릿지 ID가 4096인 스위치의 포트가 경로값이 19이므로 지정 포트가 된다. 반면 브릿지 ID가 8192인 스위치의 포트는 경로값이 119이다. 그럼 다음과 같이 포트가 지정된다.

![image](https://user-images.githubusercontent.com/50439622/147046333-c54cd570-7fd6-40eb-819e-2451ba4c8aa0.png)

최종적으로 브릿지 ID가 8192인 스위치의 포트가 블락 포트로 지정된다. 블락 포트로는 BPDU만을 수신할 뿐 데이터가 송신/수신될 수 없다. ARP와 같이 목적지가 'ff:ff:ff:ff:ff:ff'로 이루어진 이더넷 프레임은 이 포트에서 막힐 것이다. 즉 루프가 돌지 않는 것이다. 여기서 스위치를 아무데나 더 붙여도 위의 규칙을 지킨다면 각 포트는 알맞은 역할을 갖게 된다.

여기까지가 스패닝 트리 프로토콜의 동작 과정이다. 

 #### 정리 & Next Step

스패닝 트리 프로토콜이 활성화 되면 각 포트는 '역할(Role)'을 갖게 된다. '**Root Port(이하 루트 포트)**', '**Designated Port(이하 지정 포트)**', '**Alternated Port(이하 블락 포트)**'가 바로 그것이다. 루트 포트는 Root Bridge(이하 루트 브릿지)로 향하는 가장 가까운 포트를 의미하고, 지정 포트는 데이터를 전달할 수 있는 포워딩 포트, 블락 포트는 논리적인 차단된 포트이다.

**포트의 역할이 할당되고 나서 맡은 역할로 변경되기 까지 일련의 과정을 거쳐야 한다.** 즉 스위치가 켜지고 나서 POST(Power on self test)를 거치고 여러 스위치와 연결되며 스패닝 트리 프로토콜이 활성화 된 후, 포트의 역할을 결정하며 해당 역할로 나아가기 위해 포트는 몇 가지의 상태 변화를 겪게 된다. 즉 **루트 포트 / 지정 포트**처럼 BPDU와 데이터를 송수신하는 포트로 결정되었다고 해서 즉각적으로 포트가 '전송'의 역할을 맡는 것이 아니고, BPDU만을 받는 **블락 포트**로 결정되었다고 해서 즉시 '차단'의 역할을 맡는 것이 아니다. 스패닝 트리 프로토콜은 네트워크 내 브로드캐스트 폭풍을 차단하는 중요한 역할을 맡고 있는 만큼 각 역할로 가는 과정 또한 신중하게 판단한다.

위 목표를 실현하기 위해 정해진 포트의 역할, 다시 말해 전송 혹은 차단으로 향하기까지의 과정을 **상태(State)** 로 표현하여 나누고 과정마다 맡은 역할로 향하기 위해 필요한 기능을 허용 혹은 차단한다. 그 기능은 아래 목록과 같다. 그리고 **상태는 아래 3가지 기능과 밀접한 관련이 있다.** 어느 상태이냐에 따라서 허용된 기능의 가짓수가 다르다.

> 1. BPDU 송/수신
> 2. MAC 주소 학습
> 3. 데이터 전송

포트의 정해진 역할로 가는 과정을 위 3가지로 표현해보자. 먼저 BPDU를 송수신(1) 하여 서로의 우위를 정하고 포트의 역할을 결정한 후, 데이터 전송이 가능한 역할(**루트 포트 / 지정 포트**)이라면 MAC 주소 학습(2)이 가능한 상태로 변경하고 최종적으로 데이터 전송을 실시할 수 있도록 허용(3)한다. 그게 아닌 **블락 포트**의 역할을 맡아야 한다면 어느 상태이든 즉시 MAC 주소 학습을 중단하고 데이터 전송을 차단한다. (1 허용, 2 3 차단) 그리고 위 3가지 요소의 순차적 허용 혹은 차단 과정은 **포트의 5가지 상태(State)를 통해 구분 / 변경된다.**

### 포트의 상태와 정의

 ![image](https://user-images.githubusercontent.com/50439622/147043735-94c2935c-cc74-4cfc-beed-a3646cf5e72f.png)

포트의 상태는 총 5가지로 나뉜다. **'Disabled state(이하 비활성 상태)', 'Forwarding state(이하 전송 상태, FWD)', 'Listening state(이하 청취 상태, LSN)', 'Learning state(이하 학습 상태, LRN)', 'Blocking state(이하 차단 상태, BLK)'** 가 바로 그것이다. 여기서 **비활성 상태**는 포트의 고장난 상태 혹은 포트의 Disable(Shutdown), 케이블이 연결되지 않은 상태를 의미한다. 나머지 4개 상태(청취, 학습, 전송, 차단)는 전송상태 혹은 BPDU만을 수신하는 상태와 관련이 있기 때문에 다소 복잡하다.

#### Listening state(LSN)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     X     |
|  데이터 전송  |     X     |

**청취 상태**는 포트 상태의 출발점이다. 스위치가 켜지고 다른 스위치와 연결되어 포트가 활성화되면 청취상태부터 시작한다. 청취 상태를 유지한다는 것은 이 포트가 데이터를 송수신하는 포트가 될 확률이 높다는 것을 의미한다. 다시 말해 다른 스위치와의 협상에서 해당 포트의 역할이 **루트 포트** 혹은 **지정 포트**로 결정되면 청취 상태를 유지한다. 그리고 **15초가 흐르면 청취 상태는 학습 상태로 변경**된다. 데이터와 BPDU를 송수신할 수 있는 **전송 상태**(**루트 포트** 혹은 **지정 포트**)로 나아가기 위해 다음 단계로 나아가는 것이다. 포트의 역할이 **지정 포트**이면 BPDU를 송신하기 시작한다. 

![image](https://user-images.githubusercontent.com/50439622/147046221-d6bed16c-a73c-40a1-a9bd-ca9f36ae0f8a.png)

하지만 청취 상태를 유지하던 중 다른 스위치와의 협상에서 해당 포트가 **블락 포트**로 사영되기로 결정되었다면 **즉시 차단 상태로 변경**된다. 학습 상태로 변경되기까지 15초가 걸리는 것과는 다르게 차단 상태로의 변경은 즉시 실시된다.

![image](https://user-images.githubusercontent.com/50439622/147046178-79a8dd94-defa-4351-875f-57f6bc242ae1.png)

#### Learning state(LRN)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     O     |
|  데이터 전송  |     X     |

학습 상태는 청취 상태에서 전송 상태로 가기 전에 거치는 단계로 데이터를 전송하기 위한 **MAC 주소 학습이 이루어지는 단계**이다. 청취 상태처럼 **학습 상태를 15초간 유지하면 전송 상태로 변경**된다.

![image](https://user-images.githubusercontent.com/50439622/147061850-38094a08-d432-451e-9b47-abfd11264cd0.png)

하지만 학습 상태에서 포트의 역할이 **블락 포트**로 변경되었다면 **즉시 차단** 상태로 변경된다.

![image](https://user-images.githubusercontent.com/50439622/147061914-6105535f-266e-4601-9d48-38d55e38ca88.png)

#### Forwarding state(FWD)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     O     |
|  데이터 전송  |     O     |

전송 상태는 MAC 주소 학습이 끝난 상태에서 **데이터 전송이 가능한 상태임을 의미**한다. 즉 **루트 포트 / 지정 포트**로서의 역할을 다 할 수 있는 상태임을 의미한다. 하지만 전송 상태도 포트의 역할 변화로 인해 블락 포트로 역할이 변경된다면 즉시 차단 상태로 변경된다.

![image](https://user-images.githubusercontent.com/50439622/147061959-6c106678-f050-4b2f-a586-2088e7fcf4cd.png)

#### Blocking state(BLK)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     X     |
|  데이터 전송  |     X     |

차단 상태는 말그대로 BPDU 수신을 제외한 MAC 주소 학습과 **데이터 전송이 불가능한 상태를 의미**한다. 즉 **블락 포트**로서의 역할을 다 할 수 있는 상태임을 의미한다. 차단 상태는 위에서 언급한 것처럼 청취 상태에서도, 학습 상태에서도, 전송 상태에서도 그 즉시 변경이 가능하다. 청취 / 학습 상태는 각기 학습 / 전송 상태로 가기 위해 15초를 기다리지만 **차단 상태는 기다릴 필요 없이 즉시 변경된다는 특징을 가지고 있다.** 그만큼 스패닝 트리 프로토콜은 루프 방지의 목적을 위해 존재하며 루프 발생 가능성을 차단할 수 있다면 주저하지 않고 데이터 송/수신을 차단하는 것을 알 수 있다.

차단 상태(**블락 포트**)는 필요에 따라 전송 상태(**루트 포트 & 지정 포트**)로 변경될 수 있다. 물론 MAC 주소 학습과 데이터 전송이라는 단계를 차례로 거쳐야 하기 때문에 차단 상태가 거쳐갈 수 있는 상태는 청취 상태가 유일하다. 그래야 청취 / 학습 상태를 거쳐 전송 상태로 이동할 수 있다.

![image](https://user-images.githubusercontent.com/50439622/147062007-8cbf0ac5-138e-41b0-bfe6-d4bc95f0477d.png)

차단 상태가 갖는 특징은 또 있다. 바로 **블락 포트**가 아닌 다른 역할의 포트가 비활성화 되면 **스패닝 트리 내 데이터 전송 경로가 사라졌을 떄의 반응**이다. 다시 말해 스위치간 연결이 끊어져(포트가 비활성화되어) 차단 상태를 전송 상태로 만들지 않고서는 데이터 전송이 불가능한 상황을 의미한다. 이때 '블락 포트를 보유한 스위치의 포트가 비활성화 되었을 때'와 '블락 포트를 보유하지 않은 스위치의 포트가 비활성화되었을 때'의 차단 상태 반응은 다르다.

#### 정리 & Next Step

포트의 상태 정의와 전송(**루트 포트, 지정 포트**) 상태 / 차단(**블락 포트**) 상태로 이동하는 과정에 대해 다루었다. 이어서 스위치 간 링크가 끊어질 때 포트의 역할과 상태가 어떻게 변화하는지 확인해볼 필요가 있다. 그렇기에 스위치간 연결이 끊어진 경우와 스위치 간 끊어진 연결이 다시 연결된 경우를 살펴보자.

여기서 볼 주안점은 차단 상태(**블락 포트**)에 있는 **스위치의 역할(Role)과 상태(State)의 변화**이다. 데이터 전송이 불가능한 차단 상태(**블락 포트**)를 보유한 스위치가 어떻게 상황을 인지하고 대응하는지가 중요하기 때문이다. 차단 상태에 있는 스위치를 중심으로 보자.

![image](https://user-images.githubusercontent.com/50439622/147062103-e4371c6c-ace3-4336-bcdf-de8de73ebdf0.png)

### 스위치 간 직접 연결이 끊어졌을 때

스위치 간 직접 연결이 끊어졌을 때를 먼저 보자. 여기서 '직접 연결'은 **블락 포트**를 보유한 스위치와 인접한 스위치의 링크, **블락 포트**가 아닌 다른 포트의 연결이 끊어진 상태를 의미한다. **블락 포트**를 활성화 시키지 않고서는 통신이 더 이상 불가능한 상황임을 뜻한다.

![image](https://user-images.githubusercontent.com/50439622/147062132-1a5a6fe1-3785-4184-a4c5-b81895d186a2.png)

**블락 포트**를 보유한 스위치에서 루트 스위치로 갈 수 있는 가장 최단 경로이자 전송 경로인 **루트 포트**가 링크 단절로 비활성화된 상태이다. 데이터 송수신이 불가능한 **블락 포트**를 보유한 상태에서 통신을 하기 위해서는 **블락 포트**를 **루트 포트**로 전환하는 수 밖에 없다. 그렇기 때문에 스위치는 **블락 포트의 역할을 즉시 루트 포트로 전환한다.** 이게 가능한 이유는 다른 스위치도 아닌 **블락 포트**를 보유한 자기 자신의 **루트 포트**가 비활성화 되었기 때문에 어느 스위치보다 단절 상황을 빠르게 인지할 수 있어서 이다. 그렇기에 자신의 **블락 포트**를 즉시 **루트 포트**로 전환하여 장애 상황을 회피하려고 하는 것이다. 하지만 상태가 차단에서 즉시 전송으로 변경되는 것은 아니다. **블락 포트**가 **루트 포트**로 변하기 위해서는 청취상태(15초)와 학습 상태(15초)를 거쳐야 하기 때문이다. 두 단계를 거쳐야 비로소 전송 상태로 전환된다.

![image](https://user-images.githubusercontent.com/50439622/147062168-31e0eee0-6df8-4bad-8961-7ebff9227931.png)

이를 다르게 말하면 링크 단절 후 30초간은 통신이 되지 않는다는 것을 의미한다. **네트워크에서 30초간의 통신 단절은 꽤 긴 시간이다.**

### 스위치 간 간접 연결이 끊어졌을 때

이번엔 스위치 간 간접 연결이 끊어졌을 때를 보자. 여기서 '간접 연결'은 **블락 포트**를 보유한 스위치와 인접 스위치의 링크가 아닌 다른 스위치와 인접 스위치의 링크가 단절된 상태를 의미한다. **블락 포트**를 보유한 스위치는 자신이 아닌 다른 스위치의 링크가 끊어졌을 때(포트가 비활성화 되었을 때) 어떻게 행동하는지 보자.

![image](https://user-images.githubusercontent.com/50439622/147062219-4f99e1a9-02a8-412f-8dcb-b64f3dfda295.png)

Root Bridge(이하 루트 브릿지)와 인접 스위치의 링크가 단절된 상태이다. 루트 브릿지로 향하는 가장 빠른 길이 단절된 상태이므로 전체적인 상황을 보았을 때, **블락 포트**를 보유한 스위치의 **블락 포트**를 **루트 포트**로 변경해야 통신이 가능하다.

이때 링크가 단절된 스위치(Bridge ID 4096)는 루트 브릿지와 링크가 끊어진 상태이므로 루트 스위치에게서 더이상 BPDU를 전달 받을 수 없는 상황이다. 이전에 다룬 것 처럼 **지정 포트**의 역할에는 루트 브릿지가 전달하는 BPDU를 송신하는 것도 존재한다. 그러나 위 상황에서는 **링크가 단절된 스위치(Bridge ID 4096)로 가는 스위치(Bridge ID 8192)의 포트 역할은 루트 포트**이기에 BPDU를 전달하지 않으므로 BPDU를 받지 못한다. 이에 링크가 단절된 스위치(Bridge ID 4096)은 루트 스위치가 다운되었다는 판단 아래 자신이 루트 브릿지임을 주장하는 **후순위 BPDU(루트 브릿지보다 우선순위가 뒤떨어지는 Bridge ID를 갖는 BPDU)** 를 전송하기 시작한다.

![image](https://user-images.githubusercontent.com/50439622/147062276-eeff5c99-e062-4375-813a-3f9b199ad57d.png)

하지만 링크가 단절되었을 뿐 루트 브릿지가 다운된 것은 아니다. 자신이 루트 브릿지임을 주장하는 후순위 BPDU를 전달받은 스위치(Bridge ID 8192)는 링크가 단절된 스위치(Bridge ID 4096)를 루트 브릿지로 판단하지 않고 잠자코 후순위 BPDU를 받는다. 그리고 **후순위 BPDU를 10번 받으면서(총 20초, BPDU 전송 간격 2초) 블락 포트**를 통해 루트 브릿지가 전송하는 BPDU가 들어오고 있는지 파악한다. 루트 브릿지가 전송하는 BPDU가 여전히 들어오고 있음이 확인되면 스위치(Bridge ID 8192)는 루트 브릿지와 인접 스위치(Bridge ID 4096)의 링크가 단절되었음을 알게 된다.

스위치(Bridge ID 8192)는 **블락 포트**의 역할을 **루트 포트**로 전환하여 통신 준비를 시작한다.(청취 상태 15초, 학습 상태 15초) 링크가 단절된 스위치로 향하는 기존의 **루트 포트**는 **지정 포트**로 전환하고, 루트 브릿지가 전송하는 BPDU를 링크가 단절된 스위치(Bridge ID 4096)에게 고스란히 전달하며 이미 우선순위가 높은 루트 브릿지가 건재하므로 루트 브릿지가 될 생각하지 말라고 알려준다. 이에 링크가 단절된 스위치(Bridge ID 4096)는 루트 브릿지가 살아있음을 알고 더이상 후순위 BPDU를 전송하지 않으며 자신의 **지정 포트**를 **루트 포트**로 전환한다.

![image](https://user-images.githubusercontent.com/50439622/147062320-a59b6835-a74d-48a8-9cac-e3e47b35ceb4.png)

루트 브릿지와 인접 스위치의 링크가 단절된 이후, 후순위 BPDU를 받는 20초에 더해 청취 상태 15초와 학습 상태 15초를 거쳐 총 50초가 지난 후에야 **블락 포트**가 **루트 포트**로 전환된다. **네트워크에서 50초 간의 통신 단절은 꽤 긴 시간이다.**

### 끊어졌던 스위치 간 연결이 다시 연결 되었을 때

마지막으로 볼 것은 끊어졌던 스위치 간 연결이 다시 연결되었을 때이다. 아래 그림과 같이 단절되었던 링크가 부활하면서 루트 브릿지와 링크가 단절된 스위치(Bridge ID 4096)가 다시 연결되었다.

![image](https://user-images.githubusercontent.com/50439622/147062373-a5abfeee-b78a-4d17-aad4-5e45e899f332.png)

링크가 되살아났으니 연결이 끊어졌던 두 스위치 사이의 포트가 활성화 될 것이다. 그리고 서로 BPDU를 주고받으며 각 포트의 역할(루트 브릿지 : **지정 포트**, 하단 스위치 : **루트 포트**)을 결정한 뒤 두 포트 모두 청취 상태로 전환된다. 그리고 30초를 기다려 전송 상태로 변경된다.

한편 **블락 포트**(차단 상태)에서 **루트 포트**(전송 상태)로 전환 되었던 스위치(Bridge ID 8192)는 링크가 단절되었던 스위치를 통해 BPDU를 전달받고 링크가 되살아났음을 알아차린다. 그리고 **루트 포트**를 즉시 **블락 포트**(차단 상태)로 전환한다.

![image](https://user-images.githubusercontent.com/50439622/147062413-fecbae4a-c5bf-4d45-a5cf-0349d1f8d4a7.png)

여기서 한 가지 기억해야 할 점은 루프가 발생할 수 있는 구조가 되면 **블락 포트**를 맡아야 할 포트는 즉시 차단된다는 점이다. 그런데 비활성 상태에서 각각 **루트 포트**와 **지정 포트**의 역할을 맡아 상태가 변환되는 포트들은 어떻게 될까? 청취 상태와 학습 상태를 거쳐 전송 상태로 전환된다. 이 말은 다시 말하면 30초간 통신이 되지 않는 장애 상황에 놓임을 의미한다.

![image](https://user-images.githubusercontent.com/50439622/147062531-71336172-a263-4075-9da6-090fa985b1db.png)

위에서 각 상황을 설명하면서 30초와 50초는 네트워크에서 꽤 긴시간이라고 언급했다. 장애 상황을 대처함에 있어서 긴 시간을 기다려야 하는 것도 문제인데 장애 상황을 복구함에도 30초간 통신 중단이라는 상황에 놓인다는 것은 정말 치명적인 단점이 아닐 수 없다. 이러한 문제를 해결하기 위해 만든 프로토콜이 바로 **Rapid Spanning Tree Protocol, RSTP**이다.

출처 :https://aws-hyoh.tistory.com/173



## RSTP (Rapid Spanning Tree Protocol) - IEEE 802.1w

### RSTP Introduction

RSTP의 경우 위에서 언급한 것과 같이 STP의 한계를 보완하고자 만들어진 프로토콜이다. 한마디로 STP의 절체 메커니즘 중 가장 문제가 되었던 **절체 시간**을 최대한 단축하기 위한 STP의 revision이라고 봐도 좋다. 기존의 STP의 근본적인 개념과 기본적인 Tree topology 형성방법은 그대로 유지한 채, active topology에 변화가 발생하였을 때 빠르게 새로운 경로를 형성하기 위한 **이웃한 브릿지 간의 negotiation 방법론**을 도입하였다.

- STP의 한계

> 스위치 Network 망에서 장애 발생 시 작동하는 STP 동작 시간은 30~50초
>
> Convergence Time(수렴 시간)을 단축시키는 UplinkFast, BackboneFast 등등 방법이 있지만 한계가 있음.

RSTP는 자신의 BPDU 정보가 우세하면 곧바로 자신이 **지정 포트** 임을 주장하는 **Proposal BPDU**를 전달하게 된다. Proposal BPDU를 수신한 상대 Port는 자신이 루트 포트가 되겠다는 **Agreement BPDU**를 보내면서 해당 Port를 지정 포트로 변경하고, 두 포트 모두를 전송 상태로 변경한다. RSTP는 이 과정이 거의 **순간적으로 전송 상태로 변경**이 된다.

RSTP는 STP와 Port의 역할이 동일하나 **Backup port(이하 백업 포트)** 가 추가된다. 백업 포트는 지정 포트가 다운되면 그 역할을 이어 받으며, 루트 스위치에서 BPDU를 보낼 때 두 포트 중 **후순위의 포트가 백업 포트로 결정**된다. 즉, 동일한 세그먼트 내의 **하나의 스위치에서 2개 이상의 링크**가 접속되어 있을 때 **백업 포트**가 생성되며, 데이터 프레임을 송/수신 하지 않고 **차단 상태**로 있게된다.

### 포트의 상태 정의

RSTP는 Port 의 상태를 '**폐기(Blocking), 학습(Learning), 전송(Forwarding)**' 상태로 구분한다.

#### 폐기(Blocking)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     X     |
|  데이터 전송  |     X     |

STP의 차단(Blocking)과 동일하며, 데이터 프레임을 송/수신 하지 않고 **차단**하며 **BPDU만 수신** 한다.

#### 학습(Learning)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     O     |
|  데이터 전송  |     X     |

STP의 학습(Learning)과 동일하며, MAC 주소 테이블을 채우기 시작하며, 지정 포트일 경우 BPDU를 전송한다. STP와는 다르게 **전송 지연 타이머가 매우 짧다.**

#### 전송(Forwarding)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     O     |
|  데이터 전송  |     O     |

STP의 전송(Forwarding)과 동일하며, 데이터 프레임을 정상적으로 송/수신 하기 시작한다.

#### STP와 RSTP의 포트 역할과 상태 차이점

![image](https://user-images.githubusercontent.com/50439622/147316204-21be835a-520b-463e-a936-4b9042fa4ebb.png)

**루트 포트**와 **지정 포트**는 STP, RSTP 둘다 동일 하다. STP에서는 블락되어있는 포트를 **non-designated port(이하 지정되지 않은 포트)** 라고 하고 RSTP에서는 **alternative port(이라 대체 포트)**  또는 **backup port(이하 백업 포트)** 라고 한다. 대체 포트와 백업 포트는 차이가 존재한다. STP의 지정되지 않은 포트를 RSTP에서는 **대체 포트**라고 보면 된다. 즉, **장비간의 비교를 했을 때 우선 순위에서 밀려서 블락이 된 포트**를 말한다. RSTP에서 말하는 **백업 포트**는 허브 연결과 같이 이중 연결 할때 루프를 돌게 되니까 한 선은 블락되야 하는데, **우선 순위가 밀려서 블락된 포트**를 말한다. 이 포트들의 특징인 **blocking**은 STP에서만 그렇게 부르고 RSTP에서는 **discarding**이라고 한다. 그리고 STP와 RSTP의 비활성 포트는 링크가 다운된 상태를 말한다. STP는 청취 상태 - 학습 상태 - 전송 상태 의 순서와 비교적 긴 시간을 갖는데, **RSTP는 학습 상태 - 전송상태** 의 짧은 시간을 갖는다.

### Root Bridge 선택 기준

![image](https://user-images.githubusercontent.com/50439622/147178984-abbe9fd8-b8f7-435f-88bc-8f249c38e7cc.png)

- Bit 1 : Proposal BPDU가 전송하는 Port가 Designated Port 로 동작하겠다는 것을 제안할 때 사용한다.
- Bit 2-3 : Port 역할에 대한 표시
                00(미정), 01(대체 Port), 10(Root Port), 11(Designated Port)
- Bit 4 : Learning Status
- Bit 5 : Forwarding Status
- Bit 6 : 상대가 송신했던 Proposal BPDU를 수신한 포트가 그 제안을 동의해서 Root Port로 동작하겠다고 답장할 때 사용



### 동작 원리  1(초기 구성)

![image](https://user-images.githubusercontent.com/50439622/147187887-66cb524c-fa4f-40b4-bc7d-be1c2d6c5d03.png)

**루트 스위치** 선출과 같은 경우 STP 와 동일하다. 루트 스위치인 SW1은 SW2와 SW3에게 각각 **Proposal BPDU**를 송신한다. Proposal BPDU를 송신하는 Port는 항상 **지정 포트**이며, BPDU를 송신하는 동시에 **바로 지정포트의 역할**을 하게된다. SW2와 SW3은 루프가 도는것을 방지하기 위해 Proposal BPDU를 수신한 Port를 제외한 모든 Port를 **차단**한다. 또한 SW2와 SW3은 SW1과 연결된 Port들을 **루트 포트**로 사용하겠다는 **Agreement BPDU**를 SW1에게 송신함과 동시에 **루트 포트**로 변경 및 **전송상태**로 변경한다. **Agreement BPDU**를 수신한 SW1은 모든 Port를 **전송상태**로 변경한다. 위의 그림에서 SW2와 SW3의 관계를 보면 BID가 낮은 SW2의 Fa0/2가 **지정 포트** 역할을 하게 된다. SW3의 경우 Fa0/2는 **대체 포트**가 되고, **루트 포트**가 아니므로 **Agreement BPDU**를 송신할 수 없다. SW2의 경우 Fa0/2는 **지정 포트**이므로 **Proposal BPDU**를 SW3에게 송신하게 된다. SW2는 **Agreement BPDU**를 받지 못하며 차단상태(STP에서 청취 상태에 해당)에서 15초 동안 계속 BPDU를 전송한다. 15초 동안 응답이 없으면 학습 상태로 변경되며 이 상태에서도 15초 동안 BPDU를 전송하며 15초 후에 전송상태로 변경된다.

![image-20211223134457195](C:\Users\hdn\AppData\Roaming\Typora\typora-user-images\image-20211223134457195.png)

새로운 BPDU를 받으면 다른 스위치와의 연결을 블락하고 자신이 알고 있는 기존의 루트와 비교 후에 기존의 루트 스위치보다 더 좋은 정보라면 바로 루트 포트로 만든다. 나머지 스위치에게 새로운 루트에 대한 정보를 주면서 **자신을 루트포트로 삼지 않겠냐는 제안을 한다. 정보를 수집 (STP의 청취 상태) 하는 것이 아닌 Hop-by-Hop으로 새로운 루트 정보를 전달하며 동기화 하는 것이 RSTP의 핵심이다.**

### 동작 원리 2 (장애 발생)

![image-20211223135022147](C:\Users\hdn\AppData\Roaming\Typora\typora-user-images\image-20211223135022147.png)

![image-20211223135102391](C:\Users\hdn\AppData\Roaming\Typora\typora-user-images\image-20211223135102391.png)

STP인 경우 SW2로 부터 후순위 BPDU를 SW3이 10번 받으면서 (Defailt Age-Max 20Sec) 20초를 기다리고, Listening - Learning - Forwarding 까지 **50초 소요**된다.

RSTP인 경우 SW3은 SW2가 송신한 후순위 BPDU 수신 시 자신의 Fa0/2는 응답으로 Agreement BPDU를 보내고 이를 수신한 SW3의 Fa0/2 Port는 즉시 Blocking - Forwarding 으로 변경된다. **(이 변경 시간이 단 1초도 걸리지 않음)**

## PVST (Per VLAN Spanning Tree)

STP의 한 타입으로 STP는 브리징 루프를 방지하기 위해 스패닝 트리라는 트리 구조를 만든다. 그런데 전통적으로 사용하는 스패닝 트리는 VLAN과는 상관없이 물리적 구조(스위치의 트렁크 링크로 연결된)를 바탕으로 하기 때문에 단 하나의 트리만을 만들어 버린다. 이럴 경우 이 물리적 트리구조에 일부분만을 차지하는 VLAN은 어쩔 수 없이 하나로 이루어진 전체 트리를 바탕으로 운용되고 때에 따라서는 부적절한 구조를 형성할 수 도 있다. 이런 형식을 Common-Spanning Tree라 한다. 이를 보완하기 위해 VLAN마다 트리를 만들고 독자적으로 스패닝 트리 알고리즘을 수행한다. 이를 PVST(Per VLAN Spanning Tree)라 한다.

**그런데 이 PVST는 CST와 공존할 수 없고 서로의 STP BPDU를 이해 할 수 없다.** 그래서 만들어진 것이 PVST+이다. 이 PVST+는 CST에서 받은 정보를 PVST로 보낼 때 VLAN마다 반복해서 보내는 작업을 하거나 터널링을 해서 떨어진 PVST간에 연결을 하게 한다.

1. Common Spanning Tree(CST)는 IEEE 802.1Q의  

   스위치에 processing overhead가 적다.           

   하나의 루트브릿지 만을 기준으로 하기때문에, 부적절한 Forwarding Path가 생성될 수 있다.

스위치는 VLAN 마다 STP가 독립적으로 동작하는 PVST(Per VLAN Spanning Tree)를 지원한다. PVST(Per VLAN Spanning Tree)는 VLAN 마다 STP가 하나씩 돌기 때문에 하나의 VLAN에서 루프가 발생하여 전체 네트워크가 다운되는 현상을 막을 수 있다. PVSTP는 각 VLAN마다 하나의 Instance가 존재한다. 즉 VLAN이 10개이면 10개의 VLAN Instance가 존재하고 이것은 스위치 cpu에 부하를 일으킨다. 따라서 몇몇 VLAN을 묶어서 그 VLAN들 끼리는 같은 VLAN Instance를 지니게 해서 부하를 줄이는데 이것이 MSTP이다.

## MSTP (Multiple Spanning Tree Protocol) - IEEE 802.1s

### 1. Logical and Physical Topologies

MSTP의 핵심 개념은 용장 physical 토폴로지의 다른 스패닝트리(논리 토폴로지)가 소량밖에 없다는 사실을 이용하는 것이다. 다음 그림은 루트 브릿지의 배치에 따라 발생할 수 있는3개의 스위치와 3개의 다른 스패닝트리의 링토폴로지를 나타내고 있다.

![image](https://user-images.githubusercontent.com/50439622/160736678-8ef0b85f-2788-47bd-a293-38a2adc6390a.png)

MSTP는 VLAN마다 STP 인스턴스를 실행하는 것이 아니라 VLAN에 의존하지 않는 다수의 STP 인스턴스(논리 토폴로지를 나타냄)를 실행하고 관리자는 각 VLAN을 가장 적절한 논리 토폴로지(STP 인스턴스)에 매핑한다. STP 인스턴스의 수는 최소로 유지되지만(스위치자원 절약), 네트워크 capacity는 VLAN 트래픽에 가능한 모든 경로를 사용하여 보다 최적의 방법으로 활용된다.

VLAN 트래픽 전송용 스위치로직이 조금 변경되었다. 프레임을 포토로부터 전송 하려면 , 다음의 2개의 조건을 만족할 필요가 있다. 첫 번째는 VLAN이 포트상에서 active하게 되어 있을 필요가 있는 것(필터링 되어 있지 않은 것 등), 두 번째는 VLAN이 매핑하는STP 인스턴스가 이 포트에 대해서 non-discarding state가 되어 있을 필요가 있다. MAC 주소는 discarding 포트에서 학습되지 않기 때문에 두 번째 속성은 일반적으로 자동으로 적용된다. 1개의 포트로 active한 복수의 논리 토폴로지로 인해 포트는 1개의 인스턴스에서 블로킹되어 다른 인스턴스로 전송될 수 있다. 다음 그림은 2개의 MSTP 인스턴스를 사용하는 6개의 VLAN을 나타내고 있다. 따라서 PVST에서 필요한STP 트리의 수를 6개에서2개로 줄입니다.

![image](https://user-images.githubusercontent.com/50439622/160737575-6b8a69b2-c18c-4818-bf5c-66d30b213b6e.png)

### 2. MSTP Single-Region Configuration Example

![image-20220330113319496](C:\Users\hdn\AppData\Roaming\Typora\typora-user-images\image-20220330113319496.png)

토폴로지에는 1, 10, 20, 30, 40, 50, 60의 VLAN이 있다. 이 시나리오의 목표는 다음과 같다.

- VLAN 10, 20, 30이 SW3에서 SW1로 follow the link 되도록 한다.
- VLAN 40, 50, 60이 SW3에서 SW2로 follow the link 되도록 한다.
- 위의 링크 중 하나에 장애가 발생하면 영향을 받는 VLAN이 다른 링크로 폴백된다.

이를 위해 인스턴스1 인스턴스2, 2개의 MSTI를 만든다.SW1은 인스턴스1의 루트가 되고 SW2는 인스턴스2의 루트가 된다. IST(MSTI0)에 대해서는 SW3를 루트 스위치로 하고 있다(단, 액세스스위치에 루트 역할을 할당하는 것은 권장되지 않는다). VLAN에서 MSTI로의 매핑에 대해서는 VLAN 1은 IST에 매핑된 채로 있다. 나머지 VLAN 10, 20, 30은 MSTI1을 매핑하고 VLAN 40, 50, 60은 MSTI2에 매핑한다. 구성은 다음과 같다.

- SW1

  ```
  spanning-tree mode mst
  !
  spanning-tree mst configuration
   name REGION1
   instance 1 vlan 10, 20, 30
   instance 2 vlan 40, 50, 60
  !
  ! Root for MSTI1
  !
  spanning-tree mst 1 priority 8192
  !
  interface FastEthernet0/13
   switchport trunk encapsulation dot1q
   switchport mode trunk
  !
  interface FastEthernet0/16
   switchport trunk encapsulation dot1q
   switchport mode trunk
  ```

- SW2

  ```
  spanning-tree mode mst
  !
  spanning-tree mst configuration
  name REGION1
  instance 1 vlan 10, 20, 30
  instance 2 vlan 40, 50, 60
  !
  ! Root for MSTI 2
  !
  spanning-tree mst 2 priority 8192
  !
  interface FastEthernet0/13
  switchport trunk encapsulation dot1q
  switchport mode trunk
  !
  interface FastEthernet0/16
  switchport trunk encapsulation dot1q
  switchport mode trunk
  ```

- SW3

  ```
  spanning-tree mode mst
  !
  spanning-tree mst configuration
  name REGION1
  instance 1 vlan 10, 20, 30
  instance 2 vlan 40, 50, 60
  !
  ! Root for the IST
  !
  spanning-tree mst 0 priority 8192
  !
  interface FastEthernet0/13
  switchport trunk encapsulation dot1q
  switchport mode trunk
  !
  interface FastEthernet0/16
  switchport trunk encapsulation dot1q
  switchport mode trunk
  ```

다음 show 명령어는 이 설정이 트래픽 전송에 미치는 영향을 보여준다.

- SW1#**show spanning-tree mst**

  ```
  ##### MST0 vlans mapped: 1-9,11-19,21-29,31-39,41-49,51-59,61-4094
  Bridge address 0019.5684.3700 priority 32768 (32768 sysid 0)
  Root address 0012.d939.3700 priority 8192 (8192 sysid 0)
  port Fa0/16 path cost 0
  Regional Root address 0012.d939.3700 priority 8192 (8192 sysid 0)
  internal cost 200000 rem hops 19
  Operational hello time 2 , forward delay 15, max age 20, txholdcount 6
  Configured hello time 2 , forward delay 15, max age 20, max hops 20
  
  Interface Role Sts Cost Prio.Nbr Type
  ---------------- ---- --- --------- -------- --------------------------------
  Fa0/13 Desg FWD 200000 128.15 P2p
  Fa0/16 Root FWD 200000 128.18 P2p
  
  ##### MST1 vlans mapped: 10,20,30
  Bridge address 0019.5684.3700 priority 8193 (8192 sysid 1)
  Root this switch for MST1
  
  Interface Role Sts Cost Prio.Nbr Type
  ---------------- ---- --- --------- -------- --------------------------------
  Fa0/13 Desg FWD 200000 128.15 P2p
  Fa0/16 Desg FWD 200000 128.18 P2p
  
  ##### MST2 vlans mapped: 40,50,60
  Bridge address 0019.5684.3700 priority 32770 (32768 sysid 2)
  Root address 001e.bdaa.ba80 priority 8194 (8192 sysid 2)
  port Fa0/13 cost 200000 rem hops 19
  
  Interface Role Sts Cost Prio.Nbr Type
  ---------------- ---- --- --------- -------- --------------------------------
  Fa0/13 Root FWD 200000 128.15 P2p
  Fa0/16 Altn BLK 200000 128.18 P2p
  ```

- SW1#**show spanning-tree mst interface fastEthernet 0/13**

  ```
  FastEthernet0/13 of MST0 is designated forwarding
  Edge port: no (default) port guard : none (default)
  Link type: point-to-point (auto) bpdu filter: disable (default)
  Boundary : internal bpdu guard : disable (default)
  Bpdus sent 561, received 544
  
  Instance Role Sts Cost Prio.Nbr Vlans mapped
  -------- ---- --- --------- -------- -------------------------------
  0 Desg FWD 200000 128.15 1-9,11-19,21-29,31-39,41-49,51-59
  61-4094
  1 Desg FWD 200000 128.15 10,20,30
  2 Root FWD 200000 128.15 40,50,60
  
  SW1#show spanning-tree mst interface fastEthernet 0/16
  
  FastEthernet0/16 of MST0 is root forwarding
  Edge port: no (default) port guard : none (default)
  Link type: point-to-point (auto) bpdu filter: disable (default)
  Boundary : internal bpdu guard : disable (default)
  Bpdus sent 550, received 1099
  
  Instance Role Sts Cost Prio.Nbr Vlans mapped
  -------- ---- --- --------- -------- -------------------------------
  0 Root FWD 200000 128.18 1-9,11-19,21-29,31-39,41-49,51-59
  61-4094
  1 Desg FWD 200000 128.18 10,20,30
  2 Altn BLK 200000 128.18 40,50,60
  ```

링크 cost value는 default STP cost(IEEE 표준 values)보다 훨씬 높으며, MSTIx는 MSTx(예: IST or MST0)라고 불린다. 또, 밑에서 자세하게 다루는 **Regional Root**에 대해 주의해야한다.

### 3. Common and Internal Spanning Tree(CIST)

 앞에서 설명한 바와 같이 모든 MSTP 영역은 **IST 또는 내부 스패닝 트리(=MSTI0)로 알려진 스패닝 트리의 특별한 인스턴스를 실행**한다. 이 인스턴스는 주로 MSTI의 STP 토폴로지 정보를 전파하는 목적으로 사용된다. IST에는 루트브릿지가 있으며 우선순위가 가장 높은 브릿지 ID(브릿지priority + MAC 주소)에 따라 선택된다. 네트워크 내의 여러 MSTP 영역에 따라 상황이 달라진다. 스위치는 다른 지역(또는 STP/PVST+ BPDU)으로부터 송신된 BPDU 메시지를 검출하면, 대응하는 포트를 MSTP 경계로서 마크 한다. 편의상 다른 모든 포트를 "internal"이라고 부른다. 경계 포트가 있는 스위치는 경계 스위치라고 불린다.

다음 그림에서는 각 영역 쌍 간의 링크 쌍을 사용하여 "링" 토폴로지로 상호 연결된 3개의 MSTP 영역을 볼 수 있다. region을 연결하는 링크는 boundary 포트를 연결한다. 모든 스위치는 다른 region과의 접속이 있기 때문에 모든 스위치가 boundary이다. 링크 cost 및 브리지 priority의 간소화 한 표기법에 주의해야 한다. 링크 cost 및 브리지 priority는 CIST가 어떻게 구성되는지 보여주기 위해 사용된다. 알기 쉽게 하기 위해 region 내 링크 cost는 모두 같은 값 1이라고 가정한다.

![image](https://user-images.githubusercontent.com/50439622/160753731-a2e86f1f-a6ec-446f-a56f-a8bcefb7de58.png)

여러 region이 서로 연결되어 있는 경우 각 region은 자체 IST를 구축해야 하며 모든 region은 해당 region에 걸쳐 하나의 공통 CIST를 구축해야 한다. 이것을 실현하는 방법을 확인하려면 , 우선 MSTP BPDU 의 구조를 봐야한다. 다음 그림에서는 MSTP가 RSTP 버전2가 아닌 프로토콜버전 3 을 사용하고 있는 것을 알 수 있다. 버전 4는 새로운 IEEE 802.1aq 문서에서 정의된 SPT - Shortest Path Tree - 새로운 루프 방지 및 패킷브리징 표준으로 예약되어 있다.

![image-20220330135330484](C:\Users\hdn\AppData\Roaming\Typora\typora-user-images\image-20220330135330484.png)

MSTP BPDU에는 2개의 중요한 정보 블록이 포함되어 있다. 하나는 빨간색으로 강조 표시된 CIST Root 및 CIST Regional Root 선정과 관련되어 있다. 나중에 설명하겠지만 CIST 루트는 모든 region에서 선택되고 CIST Resional Root는 모든 지역에서 선택된다. 녹색 블록은 CIST Resional Root(복수의 region이 존재하는 경우 IST 루트가 됨)에 대한 정보의 개요를 나타낸다. CIST 내부 root path cost는 CIST region root에 도달하기 위한 rigion 내 cost이다. 여러 지역이 상호 운용하는 경우 IST root = CIST region root라는 점에 유의해야 한다. 이 변환에 대해서는 본문에서 자세히 설명한다. 다음으로 CIST root 역할과 CIST regional root 역할을 정의하려면 다음 절차를 수행한다.

- CIST Root는 모든 region 중 브릿지 ID가 가장 낮은 브릿지이다. 이것은 영역 내의 브리지 또는 영역 내의 boundary 스위치일 수 있다.
- CIST Regional Root는 CIST Root에 도달하기 위한 최단 external path cost에 따라 region별로 선택되는 boundary 스위치이다. path cost는 internal region path를 제외한 region을 연결하는 링크의 cost에 따라 계산된다. **CIST Regional Root도 지정된 지역의 IST 루트**가 됩니다.

#### CIST Root Bridges Election Process

- 스위치가 기동하면, CIST Root 및 CIST Regional Root 로서 자신을 선언해, 발신 BPDU로 이 사실을 알린다. 스위치는 보다 나은 정보를 수신하면 결정을 조정하고 모든 내부 포트에서 가장 잘 알려진 CIST Root 및 CIST Resional Root의 광고를 계속한다. boundary 포트에서 스위치는 CIST Root Bridge ID와 CIST External Root Path Cost만 광고하기 때문에 Region Internal 토폴로지의 자세한 내용은 숨긴다.
- CIST External Root Path Cost는 Boundary 포트(지역 간 링크)에 접속하는 링크를 통해 CIST 루트에 도달하기 위한  cost이다. 내부 포트로 BPDU 를 수신해도, 이 cost는 변경되지 않는다. BPDU 를 boundary 포트로 받으면 이 cost는 수신 boundary 포트 cost에 근거해 조정된다. 그 결과 CIST External Root Path Cost는 변경 없이 영역 내에서 전파된다.
- **CIST Resional Root로 선택할 수 있는 것은 boundary 스위치뿐**이며, CIST Root에 도달하기 위한 비용이 가장 낮은 스위치입니다. 경계 스위치는 내부 링크에서 수신된 CIST External Root Path Cost를 더 잘 수신받게 되면 CIST Resional Root의 역할을 포기하고 경계 포트에서 새로운 메트릭의 방송을 시작한다.
- 모든 경계 스위치는 경계 포트를 적절하게 차단해야 한다. 스위치가 CIST Resional Root일 경우 경계 포트 중 하나를 'CIST Root Port'로 선택하고 다른 모든 경계 포트를 차단한다. 경계 스위치가 CIST Resional Root가 아닌 경우 경계 포트는 CIST Designated 또는 Alternate로 마킹된다. non-regional-root 브리지의 경계 포트는 CIST 루트에 대한 상위 정보가 있는 경우에만 지정된다. 비용이 CIST Resional Root Bridge ID와 동일한지 여부를 확인합니다. 이것은 STP 프로세스의 통상의 룰에 따른다.
- CIST를 구축한 결과 각 영역에는 CIST 루트 방향으로 블록되지 않은 단일 포트를 가진 스위치가1개씩 배치된다. 이 스위치는 CIST Resional Root이다. 모든 경계 스위치는 지역 CIST Resonal Root 브리지 ID를 비블로킹 경계 포트에서 광고한다. 외부에서 보면 지역 전체가 브릿지 ID = CIST Resional Root ID 및 CIST Resional Root 스위치로 선택된 단일 루트포트를 가진 단일 가상 브릿지로 보인다.
- CIST 루트를 포함하는 영역에는 모든 경계 포트가 차단 해제되어 CIST 지정 포트로 마킹된다. 사실상 Resion은 브리지 ID가 CIST 루트와 동일하고 모든 포트가 지정되는 가상 루트브릿지처럼 보인다. CIST 루트가 있는 Resion은 CIST 루트와 동일한 CIST Resional Root를 가지며 모든 Resion에서 브리지 priority 값이 가장 낮다.

아래 그림에서는 앞서 설명한 physical 토폴로지를 토대로 계산한 CIST 토폴로지를 보여준다. 먼저 SW1-1은 모든 지역의 모든 브리지 중 브리지 ID가 가장 낮기 때문에 CIST Root로 선정됩니다. 이것에 의해, region 1은 자동적으로 모든 boundary 포트가 블록 해제된 가상 브릿지가 된다. 다음으로 SW2-1과 SW3-1이 각 region의 CIST Resional Root로 선출된다. SW3-1과 SW2-3은 CIST 루트에 도달하기 위한 External Root가 동일하지만 우선순위가 낮기 때문에 SW3-3이 CIST Resional Root의 역할을 획득하는 것에 주의해야 한다. MSTP 영역이 여러 개 있는 토폴로지에서는 CIST 루트가 포함되지 않은 모든 영역은 IST 루트 선택 프로세스를 변경하여 IST 루트를 CIST Resional Root와 동일하게 해야 한다.

![mstp6](https://user-images.githubusercontent.com/50439622/160761153-87dc7638-ce33-4266-8190-772464c68c6c.png)



### MSTP Basic concepts

![image](https://user-images.githubusercontent.com/50439622/160998787-c67bf655-b9f7-4095-9d1e-73101bc55b5a.png)

#### 1. MST Region

Multiple Spanning Tree Region(MST 영역)은 네트워크 내의 여러 스위치와 그 사이의 네트워크 세그먼트로 구성된다. 이러한 스위치에는 모두 다음과 같은 특징이 있다.

- 스패닝 트리 프로토콜 사용
- 동일 region name
- 동일 VLAN-to-Instance 매핑 설정
- 동일 MSTP revision level
- Physically linked

Switched network에는 복수의 MST 영역이 존재할 수 있다. 복수의 스위치를 같은 MST 영역에 할당할 수 있다. 그림 21에서 Switched network는 MST 영역1 ~ MST 영역4의 4개의 MST 영역으로 구성되어 있으며 각 MST 영역 내의 모든 스위치는 동일한 MST 영역 설정을 가지고 있다.

#### 2. MSTI

MSTP는 MST 영역에서 여러 개의 독립된 스패닝트리를 생성할 수 있으며, 각 스패닝트리는 특정 VLAN에 매핑된다.각 스패닝트리는 'Multiple Spanning Tree Instance(MSTI)'라고 불린다.

그림 22에서 MST 영역 3은 MSTI 1, MSTI 2, MSTI 0의 3개의 MSTI로 구성되어 있다.

#### 3. VLAN-to-Instance mapping table

MST region의 결과로서 VLAN과 MSTI 사이의 매핑 관계를 설명하는 것이 VLAN-to-Instance mapping table이다.

그림 22에서 MST 영역3의 VLAN-to-Instance mappint table은 VLAN 1에서MSTI 1, VLAN 2에서 MSTI 2로, 그 외의 VLAN에서 MSTI 0으로, MSTP는 VLAN-to-Instance mapping table을 사용하여 로드밸런싱을 실현한다.

#### 4. CST

Common Spanning Tree(CST; 공통 스패닝트리)는 Switched network 내의 모든 MST 영역을 접속하는 단일 스패닝트리이다. 각 MST 영역을 가상의 브릿지로 간주할 경우 CST는 이러한 브릿지에 의해 STP 또는 RSTP를 통해 계산되는 스패닝트리이다.

그림 21의 파란색 선은 CST를 나타낸다.

#### 5. IST

Internal Spanning Tree(IST; 내부 스패닝트리)는 MST 영역에서 동작하는 스패닝트리이다. **MSTI 0**이라고도 불리며, 모든 VLAN이 **default로 매핑되는 특수한 MSTI**이다.

그림 21에서 MSTI 0은 MST 영역 3의 IST이다.

#### 6. CIST

Common and Internal Spanning Tree(CIST; 공통 내부 스패닝트리)는 Switched network 내의 모든 switch를 접속하는 단일 스패닝트리이다. **모든 MST region 및 CST의 IST로 구성**된다.

그림 21에서는 모든 MST 영역의 IST(MSTI 0)와 지역 간 CST가 네트워크 전체의 CIST를 구성한다.

#### 7. Regional root

IST 또는 MST region 내의 MSTI 루트브릿지는 IST 또는 MSTI의 regional root이다. 토폴로지에 따라 MST region 내의 스패닝트리에 따라 regional root가 다를 수 있다.

그림 22의 MST 영역 3에서는 MSTI 1의 regional root는 스위치 B, MSTI 2의 regional root는 스위치 C, MSTI 0(IST)의 regional root는 스위치 A이다.

#### 8. Common root bridge

Common root bridge는 CIST의 루트브릿지이다.

그림 21에서 common root bridge는 MST region 1 내의 스위치이다.

#### 9. Port roles

포트는 MSTI마다 다른 역할을 할 수 있다. 그림 23과 같이 MST region은 스위치 A, 스위치 B, 스위치 C 및 스위치 D로 구성된다. 스위치 A의 포트 A1 및 포트 A2는 common root bridge에 접속한다. 스위치 B의 포트 B2와 포트 B3가 루프를 형성한다. 스위치 C의 포트 C3 및 포트 C4는 다른 MST region에 접속된다. 디바이스 D 의 포트 D3는, 호스트에 직접 접속한다.

![image](https://user-images.githubusercontent.com/50439622/161002201-8ce8d364-a7b5-4056-b620-89976d30a8ce.png)

MSTP calculation에0는 다음 포트 역할이 포함된다.

- **Root port** : non-root bridge의 데이터를 root bridge로 전송한다. root bridge에는 root port가 없다.
- **Designated port** : downstream 네트워크 세그먼트 또는 스위치에 데이터를 전송한다.
- **Alternate port** : root port 또는 master port의 backup port로 사용된다. root port 또는 master port가 차단되면 alternate port가 이어받는다.
- **Backup port** : designated port의 backup port로서 기능한다. designated port가 비활성화되면 backup port가 새로운 designated port가 된다. 루프는 같은 스패닝트리 스위치의 2개의 포트가 연결되어 있을 때 발생하므로 스위치는 포트 중 하나를 차단한다. 차단된 포트가 백업으로 기능한다.
- **Edge port** : 네트워크 디바이스 또는 네트워크 세그먼트에는 접속하지 않고 사용자 호스트에 직접 접속한다.
- **Master port** : local MST region에서 common root bridge로의 최단 경로상의 포트로 기능한다. master port가 항상 regional root에 있는 것은 아니다. IST 또는 CIST에서는 root port이지만 다른 MSTI에서는 master port이다.
- **Boundary port** : MST 영역을 다른 MST 영역 또는 STP/RSTP 실행 스위치에 연결한다. MSTP 계산에서는 MSTI에서의 boundary port의 역할은 CIST에서의 역할과 일치한다. 그러나 master port에서는 그렇지 않다. MSTI의 master port는 CIST의 root port이다.

#### 10. Port states

MSTP 에서 포트는 다음의 몇개의 states로 구분 할 수 있다.

- **Forwarding**상태에서 포트는 BPDU 송수신, MAC 주소 학습, 유저 트래픽을 전송한다.
- **Learning** 상태에서 포트는 BPDU 송수신, MAC 주소 학습을 하며, 유저 트래픽은 전송 되지 않는다. Learning은 중간 포트 상태이다.
- **Discarding** 상태에서 포트는 BPDU 송수신만 이루어지며 MAC 주소를 학습하거나 유저 트래픽을 전송 하지 않는다.

※ MSTI가 다른 경우 포트는 MSTI 마다 다른 스테이트가 될 수 있다.

Port state는 port role에만 국한되지 않는다. 표 9는 각 port role이 지원하는 port state를 나타낸다. ( :ballot_box_with_check: 는 포트가 이 상태를 지원함을 나타내고 :no_entry: ​는 포트가 이 상태를 지원하지 않음을 나타낸다).

| Port role (right)<br />Port state (below) | Root port/master port   | Designated port         | Alternate port          | Backup port             |
| ----------------------------------------- | ----------------------- | ----------------------- | ----------------------- | ----------------------- |
| Forwarding                                | :ballot_box_with_check: | :ballot_box_with_check: | :no_entry:              | :no_entry:              |
| Learning                                  | :ballot_box_with_check: | :ballot_box_with_check: | :no_entry:              | :no_entry:              |
| Discarding                                | :ballot_box_with_check: | :ballot_box_with_check: | :ballot_box_with_check: | :ballot_box_with_check: |



![image](https://user-images.githubusercontent.com/50439622/161017027-c2f5b417-01fe-4a2a-af6c-6657f217496f.png)

