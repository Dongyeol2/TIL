# STP(Spanning Tree Protocol)

## STP(Spanning Tree Protocol) - IEEE 802.1d

### Spaaning Tree Protocol이란 무엇이며, 왜 필요한가?

> Spanning Tree Protocol(스패닝 트리 프로토콜)은 래디아 펄먼이 고안한 알고리즘에 기반한 OSI 2계층 프로토콜로 랜에서 루프 발생을 방지하기 위해 사용된다.
>
> 출처 : 위치백과 

**Spanning Tree Protocol**(이하 스패닝 트리 프로토콜)은 이더넷 프레임을 주고 받는 계층인 OSI 2계층의 프로토콜로 루프 발생 방지를 위해 만들어졌다. 루프가 발생할 수 밖에 없는 구조에서는 반드시 스패닝 트리 프로토콜을 활성화시켜야 하며 Cisco에서 생산되는 스위치들은 기본적으로 스패닝 트리 프로토콜이 활성화 되어있다. 그리고 각 VLAN 마다 루프가 발생하는 것을 막기 위해 VLAN마다 스패닝 트리 프로토콜을 활성화 시키게 되는데, 이를 **PVST(Per VLAN Spanning Tree)** 라고 부른다. Cisco 고유의 프로토콜이다.

스패닝 트리 프로토콜을 통해 실현하고자 하는 궁극적인 목표는 **루프 발생 차단**이다. 이를 실현하기 위해 스위치들은 자신들이 갖고 있는 인터페이스 중 하나를 **Block(이하 블락)** 시키고자 협상을 한다. 그래야 이더넷 프레임이 끊임없이 돌지 않고 차단된 인터페이스에서 막히게 된다. (하지만 자신의 인터페이스를 막고 싶은 스위치는 없다. 사람도 공동체의 이익을 위해 협상을 벌일 때 자신이 손해보지 않기를 바라듯이 스위치 또한 자신의 인터페이스를 막고싶어하지 않는다. 그래서 스위치간 협상을 벌이게 된다.)

![image](https://user-images.githubusercontent.com/50439622/147025231-7fcfad71-009c-425e-8ecb-d4f478365c9c.png)

스패닝 트리 프로토콜의 협상 과정은 크게 두개로 나눌 수 있다. **Root Switch 선정**과 **Port 선정**이 바로 그것이다.

```
1. Root Switch, Non Root Switch 선출
2. Root / Designated / Alternated Port 선출
```

인터페이스를 차단하려면 어떤 스위치의 인터페이스를 차단해야 할지 정해야 한다. 그래서 먼저 가장 힘센 스위치(?)를 정해야 한다. 이를 **Root Switch(이하 루트 스위치)** 라 하며 루트 스위치는 인터페이스를 블락하지 않아도 된다. 루트 스위치로 선정되지 못한 스위치들은 이 루트 스위치를 바라보며 자신이 루트 스위치와 얼마나 가까운지 경쟁한다. 루트 스위치와의 친분이 가장 적은(?) 스위치는 인터페이스를 블락해야 하는 불행을 겪어야 한다.

스위치의 서열이 정해지고 나면 이번엔 스위치 인터페이스의 서열을 정해야 한다. 스위치마다 어떤 인터페이스가 루트 스위치에 가장 가까운지 경쟁한다. 그리고 가장 경쟁력이 떨어지는 스위치의 가장 경쟁력이 떨어지는 포트가 결국 블락될 운명에 놓인다. 루트 스위치와 가장 가까운 포트를 **Root Port(이하 루트 포트)**, 차단될 운명에 놓인 포트를 **Alternated Port(이하 블락 포트)** 그리고 그 이외의 포트를 **Designated Port(이하 지정 포트)** 라 한다.

![image](https://user-images.githubusercontent.com/50439622/147026003-2cd6bb90-d25f-4481-b081-7676151b3908.png)

이 일련의 과정을 거치면 순환 구조가 사라지고 더 이상 이더넷 프레임이 빙빙 돌지 않게 된다. 스패닝 트리 프로토콜의 궁극적인 목적을 달성하는 것이다.

#### 정리 & Next Step

```
동작 과정 1 > Root Switch, Non Root Switch 선출
동작 과정 2 > Root / Designated / Alternated Port(이하 루트 / 지정 / 블락 포트) 선출
```

먼저 동작 과정 1에 해당하는 스패닝 트리 구조 내에서 Root Switch(이하 루트 스위치)로 선정될 스위치를 찾는다. 루트 스위치는 스패닝 트리 구조에서 구심점 역할을 하며 모든 Non Root Switch(이하 일반 스위치)들은 루트 스위치를 바라보고 가장 가까운 경로를 탐색한다. 스위치 간의 역할이 정리되면 동작 과정 2에 따라 일반 스위치들은 루트 스위치로 향하는 가장 가까운 경로에 있는 포트를 루트 포트로 선정하고 루트 포트의 반재 포트를 지정 포트로 지정해 데이터 이동을 가능케 한다. 그리고 루트 포트도, 지정 포트도 아닌 포트는 결국 일반 데이터 이동이 차단되는 블락 포트가 된다.

이 과정에 대해 자세히 알아보기 위해서 **Bridge Protocol Data Unit(BPDU)** 에 대해 알아야 한다.

### Bridge Protocol Data Unit(BPDU)

Bridge Protocol Data Unit(BPDU)는 루프 없는 구성, 스패닝 트리를 구성할 때 사용하는 이더넷 프레임이다. 즉, 스위치들 간의 대화 수단이다. 스위치들은 BPDU를 주고받으며 서로의 우선순위를 확인하고 루트 스위치를 결정한다. 이를 **Configuration BPDU**라고 한다. 또한 스위치 장애 혹은 스위치 간 링크 장애 발생으로 인해 네트워크에 변화가 생기면 루트 스위치에게 보고하는 경우에도 BPDU가 사용되는데 이를 **TCN(Topology Change Notification) BPDU**라고 한다.

그 중 Configuration BPDU(이하 설정 BPDU)의 구성을 보면 다음과 같다.

![image](https://user-images.githubusercontent.com/50439622/147033988-4d19b101-ae7a-4edb-972b-e10b58878a93.png)

설정 BPDU를 구성하는 다양한 정보들이 보인다. Root Bridge ID, Path Cost, Port ID 등 경로 구성에 중요한 역할을 하는 요소들이 보인다. 그 중에서 우리가 주목해야 할 것은 '**Bridge ID**'이다. Bridge ID(이하 브릿지 ID)는 각 스위치가 갖는 일련의 숫자로 스패닝 트리를 구성하고자 하는 스위치들은 이 브리지 ID의 값 크기를 비교하여 서열을 정한다. 값은 0 ~ 32768 이며 **값이 작을 수록** 더 높은 우선순위(서열)을 갖게 된다. 이 숫자는 사용자가 임의로 지정할 수 있다. 브릿지 ID를 다시 자세히 들여다보면 다음과 같이 구성된다.

![image](https://user-images.githubusercontent.com/50439622/147034263-0b02439f-2ee5-48f7-8524-a17236bf06e9.png)

'MAC 주소'는 스위치의 MAC 주소를 의미한다. 그리고 '우선 순위'는 위에서 언급한 숫자인 **0 ~ 32768**과 **VLAN 번호**를 더한 값이다. 이 두 개 값을 이용하여 브릿지 ID를 생성한다. 우선 순위에 VLAN 번호를 추가로 부여하는 이유는 VLAN별로 스패닝 트리를 구성하는 PVST(Per VLAN Spanning Tree)를 실현하기 위함이다. VLAN 번호가 없다면 모든 VLAN이 다 같은 우선순위 값을 가질 수 밖에 없을 테니 VLAN 별로 우선순위를 줄 수 없어 매우 곤란해 질 수 있다. VLAN 10번의 우선순위만 바꾸고 싶은데 VLAN 20, 30의 우선순위도 함께 바뀔 테니 말이다.

스패닝 트리 프로토콜이 동작하기 위한 중요한 요소들을 살펴 보았으니 본격적으로 스패닝 트리 프로토콜이 동작하는 과정을 살펴보도록 하자

### 동작 과정 1 > Root Switch(Root Bridge)와 Non Root Switch(Non Root Bridge) 선출

스패닝 트리 프로토콜 동작 과정에서 눈여겨볼 특이점은 **루트 스위치를 중심으로 연결되는 스위치들이 뿌리처럼 뻗어나가는 구조를 취한다는 것이다** 스위치가 추적되면 될 수록 Root Bridge(이하 루트 브릿지)가 아닌 Non Root Bridge(이하 일반 스위치)들은 모두 루트 스위치를 바라보게 된다. 마치 나무의 뿌리 모양처럼 말이다. 그래야만 루트 브릿지(루트 스위치)를 필두로 스위치 간 서열을 정리하고 인터페이스를 차단할 스위치를 정할 수 있다. 그러므로 먼저 루트 브릿지를 선출하는 과정을 살펴보자.

앞서 말한 것처럼 스위치의 서열을 정하는 것은 **Bridge ID**이다. 스위치들은 BPDU 프레임을 주고 받으며 브릿지 ID를 확인하고 누구의 서열이 더 높은지 판단한다.

![image](https://user-images.githubusercontent.com/50439622/147037045-e6d250bd-df86-4fbd-afac-4ea8c50d0fc8.png)

위 그림에서 스위치들의 브릿지 ID를 확인할 수 있다. 좌측 상단의 브릿지 ID가 가장 높고 우측하단의 스위치의 브릿지 ID가 가장 낮다. 스위치들이 연결되고 스패닝 트리 프로토콜이 동작하기 시작하면 모든 스위치들은 자신이 루트 스위치라고 주장하며 BPDU를 보내기 시작한다. 그러다 자신보다 더 높은 브릿지 ID가 담긴 BPDU를 전달받으면 더 이상 루트 브릿지임을 주장하지 않고 BPDU 프레임에 자신이 받은 가장 높은 브릿지 ID를 '**Root Bridge ID(이하 루트 브릿지 ID)**'에 담아 다른 스위치들에게 전달한다. 자신보다 높은 브릿지 ID가 담긴 BPDU 프레임을 받아든 스위치들 또한 더 이상 루트 브릿지임을 주장하지 않고 일반 스위치로서 움직인다.

![image](https://user-images.githubusercontent.com/50439622/147037060-8cdf5cfd-bc0b-4899-9920-441018db0983.png)

좌측 상단의 스위치의 브릿지 ID가 가장 높기 때문에 루트 브릿지로 선정된다. 그리고 인접한 스위치들은 루트 브릿지를 인정하고 루트 브릿지만을 바라보게 된다. 이 인접한 스위치들에 연결되는 스위치들 또한 루트 브릿지보다 브릿지 ID가 높지 않다면 마찬가지로 루트 브릿지를 바라보게 된다. 루트 브릿지가 선정되었고 스위치간 서열이 정해졌으니 이제 차단할 포트를 찾는 일이 남았다.

### 동작 과정 2 > Root / Designated / Alternated Port 선출

브릿지 ID를 통해 스위치의 서열을 정했으니 이번엔 각 스위치들의 포트의 서열을 매긴다. **이 서열은 스위치 내에서만 적용되며 다른 스위치와 경합하는 것이 아니다.** 하지만 포트의 서열 또한 루트 브릿지까지의 거리가 얼마나 가까운 지를 경쟁하는 것이기 때문에 루트 브릿지의 영향에서 벗어날 수 없다. 그 전에 기억해야 할 요소가 두 가지 있으니 바로 '**Segment(이하 세그먼트)**'와 '**Path Cost(이하 경로값)**'이다.

![image](https://user-images.githubusercontent.com/50439622/147037069-2bb0d521-58cd-407f-9bb7-9b2d52c2aa7f.png)

세그먼트는 연결된 네트워크 장비간의 연결을 뜻한다. 위 그림에서는 총 4개의 세그먼트를 확인할 수 있다.(장비간 연결이 4개 이기 때문). 세그먼트가 중요한 이유는 아래 한 가지 규칙 때문이다. 스패닝 트리 구조 내에서 어느 포트가 어떤 역할을 맡아야 할 지 헷갈릴 때 아래 규칙을 기억하면 쉽다.

> 하나의 세그먼트에는 반드시 하나의 지정 포트가 있어야 한다.

Path Cost(이하 경로값)은 포트에 적용된 속도를 값으로 변환한 것으로 속도에 대한 적용값은 다음과 같다.

|     속도 (bandwidth)     | 경로값 (path cost) |
| :----------------------: | :----------------: |
|     10 Mbps (이더넷)     |        100         |
| 100 Mbps(패스트 이더넷)  |         19         |
| 1 Gbps (기가비트 이더넷) |         4          |
| 10 Gbps (10 기가 이더넷) |       2ㄴㅇ        |

스위치와 스위치가 연결되면 Speed와 Duplex에 대해 협상을 하고 서로 동일한 Speed와 Duplex를 갖게 되는데 바로 스위치의 포트에 설정된 속도가 표에서의 속도 (Bandwidth)이다. 그리고 속도마다 다른 경로 값을 부여하고 이를 스패닝 트리 구성에 활용한다. 다시 말해 스위치 자신의 경로값과 루트 브릿지까지의 경로에 위치한 스위치의 경로값을 모두 고려한다. **루트 브릿지로 향하는 경로의 경로값을 모두 더해 가장 작은 값이 나오는 경로를 택하는 것이다.** 아래 그림에서 포트에 설정된 경로값을 확인 할 수 있다.

![image](https://user-images.githubusercontent.com/50439622/147037073-92bfdb58-9a15-434f-8944-9eb3d1ad8e3b.png)

브릿지 ID가 4096인 스위치는 루트 브릿지로 향하는 세그먼트가 하나뿐이며 경로값은 19이다. 브릿지 ID가 8192인 스위치는 두 개의 경로가 있으며 하나는 경로값이 38(19 + 19), 하나는 경로값이 119(100 + 19)이다. 경로가 두 개인데 한 쪽 경로의 값이 훨씬 작으니 스위치는 작은 경로값의 세그먼트를 통신경로로 사용할 것이 분명하다. 세그먼트와 경로값에 대해 알아보았으니 이제 본격적으로 포트를 선출하는 순서에 대해 알아보자.

#### Root Port 선출

스패닝 트리의 구성은 나무 뿌리와 같다고 할 수 있다. 가장 중요한 나무 뿌리인 루트 브릿지로 향하는 가장 가까운 포트가 먼저 선출되며 이를 루트 포트라고 한다. 데이터와 BPDU 프레임이 이동하는 포트이다. 루트 포트를 선출하는 기준은 다음과 같다.

> 1. 가장 작은 경로값을 가지는 포트
> 2. 인접한 스위치의 브릿지 ID가 가장 낮은 포트
> 3. 인접한 스위치의 포트 ID가 가장 낮은 포트(포트 ID : 포트 번호)

위의 기준을 적용해 보면 스위치들의 루트 포트는 다음과 같이 정해진자. 먼저 브릿지 ID가 4096인 스위치들은 **첫번째 기준**에 의거 루트 스위치로 향하는 경로값이 가장 적은 포트(경로값 : 19)를 루트 포트로 정하게 된다. 첫번째 기준을 충족했기 때문에 두번째, 세번째 기준을 볼 필요가 없다.

브릿지 ID가 8192인 스위치는 왼쪽으로 향하는 경로가 경로값이 훨씬 작기 때문에 왼쪽 포트(경로값 38)를 루트 포트로 선택한다. 만약 경로값이 양쪽 모두 같았다면? **두번째 기준**인 브릿지 ID가 가장 낮은 스위치를 접한 포트를 선택한다. 하지만 아래 그림을 보시다시피 인접한 스위치들은 모두 같은 브릿지 ID 값을 갖는다. 그럼 두번째 기준 또한 적용되지 않을 것이다. 그럼 **세번째 기준**을 적용한다. 인접한 스위치 모두 포트 번호가 2번 이라고 가정하면 결국 이 기준 또한 적용되지 않는다. 마지막으로 스위치는 자신의 포트 번호를 보고 가장 낮은 포트 번호(숫자가 작을수록 낮은 포트)를 루트 포트로 택하게 된다.

![image](https://user-images.githubusercontent.com/50439622/147038015-a5d3c766-facf-4005-89f8-c8d288cdeeb1.png)

#### Designated Port 선출

지정 포트는 루트 포트, 블락 포트가 아닌 포트를 이르는 말이다. 단순 포워딩 포트라고 봐도 무방하다. 데이터와 BPDU 프레임을 전송하는 포트이다. 지정 포트를 선출하기 위한 규칙은 루트 포트를 선출하는 규칙과 거의 동일하다. 블락 포트가 아닌 지정 포트를 먼저 선출하는 이유는 루트 포트와 지정 포트가 아닌 포트가 블락 포트로 지정되기 때문이다.

> 1. 가장 작은 경로값을 가지는 포트
> 2. 스위치의 브릿지 ID가 가장 낮은 포트
> 3. 스위치의 포트 ID가 가장 낮은 포트(포트 ID : 포트 번호)

하지만 이런 규칙들은 포트 선출 과정을 이해하기 어렵게 만들 뿐이다. 때문에 위에서 언급한 규칙 한가지를 활용하여 포트 선출과정을 보도록 하자

> 하나의 세그먼트에는 반드시 하나의 지정 포트가 있어야 한다.

세그먼트 하나에는 지정 포트가 하나씩 반드시 있어야 한다는 암묵적인(?) 규칙이 있다. 스위치가 실제 포트 선출에 있어 사용하는 규칙이라기보다 포트를 지정하는 과정에 나타나는 특징이다. 스패닝 트리 프로토콜 동작과정을 이해하는데 이게 좀 더 나은 것 같아 먼저 적용해보자. 아래 루트 포트가 존재하는 세그먼트에 빈 자리가 남아 있는 곳은 모두 지정 포트로 채웠다. 하나의 세그먼트에는 하나의 지정 포트가 반드시 존재해야 하기 때문이다.

![image](https://user-images.githubusercontent.com/50439622/147041424-6ec468df-2502-4601-8dfb-01aac9f197b5.png)

이제 포트가 지정되지 않은, 마지막으로 남은 세그먼트를 살펴보자.

#### Alternated Port 선출

블락 포트는 루트 포트도, 지정 포트도 아닌 포트로 데이터 통신을 하지 않는 포트이다. 그러나 BPDU는 수신한다. 블락 포트가 BPDU를 제외한 모든 트래픽을 송수신하지 않음으로써 루프가 도는 것을 방지한다. 아래 그림에서 남은 하나의 세그먼트에서 블락 포트를 지정해야 한다.

![image](https://user-images.githubusercontent.com/50439622/147046326-b9a72924-534e-4582-823d-cc07168d3ec3.png)

지정 포트 선출과정에서 하나의 세그먼트에는 반드시 하나의 지정 포트가 있어야 한다 말했다. 그렇다는건 위 세그먼트에서 두 포트 중 하나는 지정 포트가 되어야 하고 남은 하나의 포트가 블락 포트가 되어야 함을 의미한다. 바로 여기서 지정 포트 선출 기준이 사용된다.

> 1. 가장 작은 경로값을 가지는 포트
> 2. 스위치의 브릿지 ID가 가장 낮은 포트
> 3. 스위치의 포트 ID가 가장 낮은 포트(포트 ID : 포트 번호)

위의 그림에서는 1번으로 인해 브릿지 ID가 4096인 스위치의 포트가 경로값이 19이므로 지정 포트가 된다. 반면 브릿지 ID가 8192인 스위치의 포트는 경로값이 119이다. 그럼 다음과 같이 포트가 지정된다.

![image](https://user-images.githubusercontent.com/50439622/147046333-c54cd570-7fd6-40eb-819e-2451ba4c8aa0.png)

최종적으로 브릿지 ID가 8192인 스위치의 포트가 블락 포트로 지정된다. 블락 포트로는 BPDU만을 수신할 뿐 데이터가 송신/수신될 수 없다. ARP와 같이 목적지가 'ff:ff:ff:ff:ff:ff'로 이루어진 이더넷 프레임은 이 포트에서 막힐 것이다. 즉 루프가 돌지 않는 것이다. 여기서 스위치를 아무데나 더 붙여도 위의 규칙을 지킨다면 각 포트는 알맞은 역할을 갖게 된다.

여기까지가 스패닝 트리 프로토콜의 동작 과정이다. 

 #### 정리 & Next Step

스패닝 트리 프로토콜이 활성화 되면 각 포트는 '역할(Role)'을 갖게 된다. '**Root Port(이하 루트 포트)**', '**Designated Port(이하 지정 포트)**', '**Alternated Port(이하 블락 포트)**'가 바로 그것이다. 루트 포트는 Root Bridge(이하 루트 브릿지)로 향하는 가장 가까운 포트를 의미하고, 지정 포트는 데이터를 전달할 수 있는 포워딩 포트, 블락 포트는 논리적인 차단된 포트이다.

**포트의 역할이 할당되고 나서 맡은 역할로 변경되기 까지 일련의 과정을 거쳐야 한다.** 즉 스위치가 켜지고 나서 POST(Power on self test)를 거치고 여러 스위치와 연결되며 스패닝 트리 프로토콜이 활성화 된 후, 포트의 역할을 결정하며 해당 역할로 나아가기 위해 포트는 몇 가지의 상태 변화를 겪게 된다. 즉 **루트 포트 / 지정 포트**처럼 BPDU와 데이터를 송수신하는 포트로 결정되었다고 해서 즉각적으로 포트가 '전송'의 역할을 맡는 것이 아니고, BPDU만을 받는 **블락 포트**로 결정되었다고 해서 즉시 '차단'의 역할을 맡는 것이 아니다. 스패닝 트리 프로토콜은 네트워크 내 브로드캐스트 폭풍을 차단하는 중요한 역할을 맡고 있는 만큼 각 역할로 가는 과정 또한 신중하게 판단한다.

위 목표를 실현하기 위해 정해진 포트의 역할, 다시 말해 전송 혹은 차단으로 향하기까지의 과정을 **상태(State)** 로 표현하여 나누고 과정마다 맡은 역할로 향하기 위해 필요한 기능을 허용 혹은 차단한다. 그 기능은 아래 목록과 같다. 그리고 **상태는 아래 3가지 기능과 밀접한 관련이 있다.** 어느 상태이냐에 따라서 허용된 기능의 가짓수가 다르다.

> 1. BPDU 송/수신
> 2. MAC 주소 학습
> 3. 데이터 전송

포트의 정해진 역할로 가는 과정을 위 3가지로 표현해보자. 먼저 BPDU를 송수신(1) 하여 서로의 우위를 정하고 포트의 역할을 결정한 후, 데이터 전송이 가능한 역할(**루트 포트 / 지정 포트**)이라면 MAC 주소 학습(2)이 가능한 상태로 변경하고 최종적으로 데이터 전송을 실시할 수 있도록 허용(3)한다. 그게 아닌 **블락 포트**의 역할을 맡아야 한다면 어느 상태이든 즉시 MAC 주소 학습을 중단하고 데이터 전송을 차단한다. (1 허용, 2 3 차단) 그리고 위 3가지 요소의 순차적 허용 혹은 차단 과정은 **포트의 5가지 상태(State)를 통해 구분 / 변경된다.**

### 포트의 상태와 정의

 ![image](https://user-images.githubusercontent.com/50439622/147043735-94c2935c-cc74-4cfc-beed-a3646cf5e72f.png)

포트의 상태는 총 5가지로 나뉜다. **'Disabled state(이하 비활성 상태)', 'Forwarding state(이하 전송 상태, FWD)', 'Listening state(이하 청취 상태, LSN)', 'Learning state(이하 학습 상태, LRN)', 'Blocking state(이하 차단 상태, BLK)'** 가 바로 그것이다. 여기서 **비활성 상태**는 포트의 고장난 상태 혹은 포트의 Disable(Shutdown), 케이블이 연결되지 않은 상태를 의미한다. 나머지 4개 상태(청취, 학습, 전송, 차단)는 전송상태 혹은 BPDU만을 수신하는 상태와 관련이 있기 때문에 다소 복잡하다.

#### Listening state(LSN)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     X     |
|  데이터 전송  |     X     |

**청취 상태**는 포트 상태의 출발점이다. 스위치가 켜지고 다른 스위치와 연결되어 포트가 활성화되면 청취상태부터 시작한다. 청취 상태를 유지한다는 것은 이 포트가 데이터를 송수신하는 포트가 될 확률이 높다는 것을 의미한다. 다시 말해 다른 스위치와의 협상에서 해당 포트의 역할이 **루트 포트** 혹은 **지정 포트**로 결정되면 청취 상태를 유지한다. 그리고 **15초가 흐르면 청취 상태는 학습 상태로 변경**된다. 데이터와 BPDU를 송수신할 수 있는 **전송 상태**(**루트 포트** 혹은 **지정 포트**)로 나아가기 위해 다음 단계로 나아가는 것이다. 포트의 역할이 **지정 포트**이면 BPDU를 송신하기 시작한다. 

![image](https://user-images.githubusercontent.com/50439622/147046221-d6bed16c-a73c-40a1-a9bd-ca9f36ae0f8a.png)

하지만 청취 상태를 유지하던 중 다른 스위치와의 협상에서 해당 포트가 **블락 포트**로 사영되기로 결정되었다면 **즉시 차단 상태로 변경**된다. 학습 상태로 변경되기까지 15초가 걸리는 것과는 다르게 차단 상태로의 변경은 즉시 실시된다.

![image](https://user-images.githubusercontent.com/50439622/147046178-79a8dd94-defa-4351-875f-57f6bc242ae1.png)

#### Learning state(LRN)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     O     |
|  데이터 전송  |     X     |

학습 상태는 청취 상태에서 전송 상태로 가기 전에 거치는 단계로 데이터를 전송하기 위한 **MAC 주소 학습이 이루어지는 단계**이다. 청취 상태처럼 **학습 상태를 15초간 유지하면 전송 상태로 변경**된다.

![image](https://user-images.githubusercontent.com/50439622/147061850-38094a08-d432-451e-9b47-abfd11264cd0.png)

하지만 학습 상태에서 포트의 역할이 **블락 포트**로 변경되었다면 **즉시 차단** 상태로 변경된다.

![image](https://user-images.githubusercontent.com/50439622/147061914-6105535f-266e-4601-9d48-38d55e38ca88.png)

#### Forwarding state(FWD)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     O     |
|  데이터 전송  |     O     |

전송 상태는 MAC 주소 학습이 끝난 상태에서 **데이터 전송이 가능한 상태임을 의미**한다. 즉 **루트 포트 / 지정 포트**로서의 역할을 다 할 수 있는 상태임을 의미한다. 하지만 전송 상태도 포트의 역할 변화로 인해 블락 포트로 역할이 변경된다면 즉시 차단 상태로 변경된다.

![image](https://user-images.githubusercontent.com/50439622/147061959-6c106678-f050-4b2f-a586-2088e7fcf4cd.png)

#### Blocking state(BLK)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     X     |
|  데이터 전송  |     X     |

차단 상태는 말그대로 BPDU 수신을 제외한 MAC 주소 학습과 **데이터 전송이 불가능한 상태를 의미**한다. 즉 **블락 포트**로서의 역할을 다 할 수 있는 상태임을 의미한다. 차단 상태는 위에서 언급한 것처럼 청취 상태에서도, 학습 상태에서도, 전송 상태에서도 그 즉시 변경이 가능하다. 청취 / 학습 상태는 각기 학습 / 전송 상태로 가기 위해 15초를 기다리지만 **차단 상태는 기다릴 필요 없이 즉시 변경된다는 특징을 가지고 있다.** 그만큼 스패닝 트리 프로토콜은 루프 방지의 목적을 위해 존재하며 루프 발생 가능성을 차단할 수 있다면 주저하지 않고 데이터 송/수신을 차단하는 것을 알 수 있다.

차단 상태(**블락 포트**)는 필요에 따라 전송 상태(**루트 포트 & 지정 포트**)로 변경될 수 있다. 물론 MAC 주소 학습과 데이터 전송이라는 단계를 차례로 거쳐야 하기 때문에 차단 상태가 거쳐갈 수 있는 상태는 청취 상태가 유일하다. 그래야 청취 / 학습 상태를 거쳐 전송 상태로 이동할 수 있다.

![image](https://user-images.githubusercontent.com/50439622/147062007-8cbf0ac5-138e-41b0-bfe6-d4bc95f0477d.png)

차단 상태가 갖는 특징은 또 있다. 바로 **블락 포트**가 아닌 다른 역할의 포트가 비활성화 되면 **스패닝 트리 내 데이터 전송 경로가 사라졌을 떄의 반응**이다. 다시 말해 스위치간 연결이 끊어져(포트가 비활성화되어) 차단 상태를 전송 상태로 만들지 않고서는 데이터 전송이 불가능한 상황을 의미한다. 이때 '블락 포트를 보유한 스위치의 포트가 비활성화 되었을 때'와 '블락 포트를 보유하지 않은 스위치의 포트가 비활성화되었을 때'의 차단 상태 반응은 다르다.

#### 정리 & Next Step

포트의 상태 정의와 전송(**루트 포트, 지정 포트**) 상태 / 차단(**블락 포트**) 상태로 이동하는 과정에 대해 다루었다. 이어서 스위치 간 링크가 끊어질 때 포트의 역할과 상태가 어떻게 변화하는지 확인해볼 필요가 있다. 그렇기에 스위치간 연결이 끊어진 경우와 스위치 간 끊어진 연결이 다시 연결된 경우를 살펴보자.

여기서 볼 주안점은 차단 상태(**블락 포트**)에 있는 **스위치의 역할(Role)과 상태(State)의 변화**이다. 데이터 전송이 불가능한 차단 상태(**블락 포트**)를 보유한 스위치가 어떻게 상황을 인지하고 대응하는지가 중요하기 때문이다. 차단 상태에 있는 스위치를 중심으로 보자.

![image](https://user-images.githubusercontent.com/50439622/147062103-e4371c6c-ace3-4336-bcdf-de8de73ebdf0.png)

### 스위치 간 직접 연결이 끊어졌을 때

스위치 간 직접 연결이 끊어졌을 때를 먼저 보자. 여기서 '직접 연결'은 **블락 포트**를 보유한 스위치와 인접한 스위치의 링크, **블락 포트**가 아닌 다른 포트의 연결이 끊어진 상태를 의미한다. **블락 포트**를 활성화 시키지 않고서는 통신이 더 이상 불가능한 상황임을 뜻한다.

![image](https://user-images.githubusercontent.com/50439622/147062132-1a5a6fe1-3785-4184-a4c5-b81895d186a2.png)

**블락 포트**를 보유한 스위치에서 루트 스위치로 갈 수 있는 가장 최단 경로이자 전송 경로인 **루트 포트**가 링크 단절로 비활성화된 상태이다. 데이터 송수신이 불가능한 **블락 포트**를 보유한 상태에서 통신을 하기 위해서는 **블락 포트**를 **루트 포트**로 전환하는 수 밖에 없다. 그렇기 때문에 스위치는 **블락 포트의 역할을 즉시 루트 포트로 전환한다.** 이게 가능한 이유는 다른 스위치도 아닌 **블락 포트**를 보유한 자기 자신의 **루트 포트**가 비활성화 되었기 때문에 어느 스위치보다 단절 상황을 빠르게 인지할 수 있어서 이다. 그렇기에 자신의 **블락 포트**를 즉시 **루트 포트**로 전환하여 장애 상황을 회피하려고 하는 것이다. 하지만 상태가 차단에서 즉시 전송으로 변경되는 것은 아니다. **블락 포트**가 **루트 포트**로 변하기 위해서는 청취상태(15초)와 학습 상태(15초)를 거쳐야 하기 때문이다. 두 단계를 거쳐야 비로소 전송 상태로 전환된다.

![image](https://user-images.githubusercontent.com/50439622/147062168-31e0eee0-6df8-4bad-8961-7ebff9227931.png)

이를 다르게 말하면 링크 단절 후 30초간은 통신이 되지 않는다는 것을 의미한다. **네트워크에서 30초간의 통신 단절은 꽤 긴 시간이다.**

### 스위치 간 간접 연결이 끊어졌을 때

이번엔 스위치 간 간접 연결이 끊어졌을 때를 보자. 여기서 '간접 연결'은 **블락 포트**를 보유한 스위치와 인접 스위치의 링크가 아닌 다른 스위치와 인접 스위치의 링크가 단절된 상태를 의미한다. **블락 포트**를 보유한 스위치는 자신이 아닌 다른 스위치의 링크가 끊어졌을 때(포트가 비활성화 되었을 때) 어떻게 행동하는지 보자.

![image](https://user-images.githubusercontent.com/50439622/147062219-4f99e1a9-02a8-412f-8dcb-b64f3dfda295.png)

Root Bridge(이하 루트 브릿지)와 인접 스위치의 링크가 단절된 상태이다. 루트 브릿지로 향하는 가장 빠른 길이 단절된 상태이므로 전체적인 상황을 보았을 때, **블락 포트**를 보유한 스위치의 **블락 포트**를 **루트 포트**로 변경해야 통신이 가능하다.

이때 링크가 단절된 스위치(Bridge ID 4096)는 루트 브릿지와 링크가 끊어진 상태이므로 루트 스위치에게서 더이상 BPDU를 전달 받을 수 없는 상황이다. 이전에 다룬 것 처럼 **지정 포트**의 역할에는 루트 브릿지가 전달하는 BPDU를 송신하는 것도 존재한다. 그러나 위 상황에서는 **링크가 단절된 스위치(Bridge ID 4096)로 가는 스위치(Bridge ID 8192)의 포트 역할은 루트 포트**이기에 BPDU를 전달하지 않으므로 BPDU를 받지 못한다. 이에 링크가 단절된 스위치(Bridge ID 4096)은 루트 스위치가 다운되었다는 판단 아래 자신이 루트 브릿지임을 주장하는 **후순위 BPDU(루트 브릿지보다 우선순위가 뒤떨어지는 Bridge ID를 갖는 BPDU)** 를 전송하기 시작한다.

![image](https://user-images.githubusercontent.com/50439622/147062276-eeff5c99-e062-4375-813a-3f9b199ad57d.png)

하지만 링크가 단절되었을 뿐 루트 브릿지가 다운된 것은 아니다. 자신이 루트 브릿지임을 주장하는 후순위 BPDU를 전달받은 스위치(Bridge ID 8192)는 링크가 단절된 스위치(Bridge ID 4096)를 루트 브릿지로 판단하지 않고 잠자코 후순위 BPDU를 받는다. 그리고 **후순위 BPDU를 10번 받으면서(총 20초, BPDU 전송 간격 2초) 블락 포트**를 통해 루트 브릿지가 전송하는 BPDU가 들어오고 있는지 파악한다. 루트 브릿지가 전송하는 BPDU가 여전히 들어오고 있음이 확인되면 스위치(Bridge ID 8192)는 루트 브릿지와 인접 스위치(Bridge ID 4096)의 링크가 단절되었음을 알게 된다.

스위치(Bridge ID 8192)는 **블락 포트**의 역할을 **루트 포트**로 전환하여 통신 준비를 시작한다.(청취 상태 15초, 학습 상태 15초) 링크가 단절된 스위치로 향하는 기존의 **루트 포트**는 **지정 포트**로 전환하고, 루트 브릿지가 전송하는 BPDU를 링크가 단절된 스위치(Bridge ID 4096)에게 고스란히 전달하며 이미 우선순위가 높은 루트 브릿지가 건재하므로 루트 브릿지가 될 생각하지 말라고 알려준다. 이에 링크가 단절된 스위치(Bridge ID 4096)는 루트 브릿지가 살아있음을 알고 더이상 후순위 BPDU를 전송하지 않으며 자신의 **지정 포트**를 **루트 포트**로 전환한다.

![image](https://user-images.githubusercontent.com/50439622/147062320-a59b6835-a74d-48a8-9cac-e3e47b35ceb4.png)

루트 브릿지와 인접 스위치의 링크가 단절된 이후, 후순위 BPDU를 받는 20초에 더해 청취 상태 15초와 학습 상태 15초를 거쳐 총 50초가 지난 후에야 **블락 포트**가 **루트 포트**로 전환된다. **네트워크에서 50초 간의 통신 단절은 꽤 긴 시간이다.**

### 끊어졌던 스위치 간 연결이 다시 연결 되었을 때

마지막으로 볼 것은 끊어졌던 스위치 간 연결이 다시 연결되었을 때이다. 아래 그림과 같이 단절되었던 링크가 부활하면서 루트 브릿지와 링크가 단절된 스위치(Bridge ID 4096)가 다시 연결되었다.

![image](https://user-images.githubusercontent.com/50439622/147062373-a5abfeee-b78a-4d17-aad4-5e45e899f332.png)

링크가 되살아났으니 연결이 끊어졌던 두 스위치 사이의 포트가 활성화 될 것이다. 그리고 서로 BPDU를 주고받으며 각 포트의 역할(루트 브릿지 : **지정 포트**, 하단 스위치 : **루트 포트**)을 결정한 뒤 두 포트 모두 청취 상태로 전환된다. 그리고 30초를 기다려 전송 상태로 변경된다.

한편 **블락 포트**(차단 상태)에서 **루트 포트**(전송 상태)로 전환 되었던 스위치(Bridge ID 8192)는 링크가 단절되었던 스위치를 통해 BPDU를 전달받고 링크가 되살아났음을 알아차린다. 그리고 **루트 포트**를 즉시 **블락 포트**(차단 상태)로 전환한다.

![image](https://user-images.githubusercontent.com/50439622/147062413-fecbae4a-c5bf-4d45-a5cf-0349d1f8d4a7.png)

여기서 한 가지 기억해야 할 점은 루프가 발생할 수 있는 구조가 되면 **블락 포트**를 맡아야 할 포트는 즉시 차단된다는 점이다. 그런데 비활성 상태에서 각각 **루트 포트**와 **지정 포트**의 역할을 맡아 상태가 변환되는 포트들은 어떻게 될까? 청취 상태와 학습 상태를 거쳐 전송 상태로 전환된다. 이 말은 다시 말하면 30초간 통신이 되지 않는 장애 상황에 놓임을 의미한다.

![image](https://user-images.githubusercontent.com/50439622/147062531-71336172-a263-4075-9da6-090fa985b1db.png)

위에서 각 상황을 설명하면서 30초와 50초는 네트워크에서 꽤 긴시간이라고 언급했다. 장애 상황을 대처함에 있어서 긴 시간을 기다려야 하는 것도 문제인데 장애 상황을 복구함에도 30초간 통신 중단이라는 상황에 놓인다는 것은 정말 치명적인 단점이 아닐 수 없다. 이러한 문제를 해결하기 위해 만든 프로토콜이 바로 **Rapid Spanning Tree Protocol, RSTP**이다.

출처 :https://aws-hyoh.tistory.com/173



## RSTP (Rapid Spanning Tree Protocol) - IEEE 802.1w

### RSTP Introduction

RSTP의 경우 위에서 언급한 것과 같이 STP의 한계를 보완하고자 만들어진 프로토콜이다. 한마디로 STP의 절체 메커니즘 중 가장 문제가 되었던 **절체 시간**을 최대한 단축하기 위한 STP의 revision이라고 봐도 좋다. 기존의 STP의 근본적인 개념과 기본적인 Tree topology 형성방법은 그대로 유지한 채, active topology에 변화가 발생하였을 때 빠르게 새로운 경로를 형성하기 위한 **이웃한 브릿지 간의 negotiation 방법론**을 도입하였다.

- STP의 한계

> 스위치 Network 망에서 장애 발생 시 작동하는 STP 동작 시간은 30~50초
>
> Convergence Time(수렴 시간)을 단축시키는 UplinkFast, BackboneFast 등등 방법이 있지만 한계가 있음.

RSTP는 자신의 BPDU 정보가 우세하면 곧바로 자신이 **지정 포트** 임을 주장하는 **Proposal BPDU**를 전달하게 된다. Proposal BPDU를 수신한 상대 Port는 자신이 루트 포트가 되겠다는 **Agreement BPDU**를 보내면서 해당 Port를 지정 포트로 변경하고, 두 포트 모두를 전송 상태로 변경한다. RSTP는 이 과정이 거의 **순간적으로 전송 상태로 변경**이 된다.

RSTP는 STP와 Port의 역할이 동일하나 **Backup port(이하 백업 포트)** 가 추가된다. 백업 포트는 지정 포트가 다운되면 그 역할을 이어 받으며, 루트 스위치에서 BPDU를 보낼 때 두 포트 중 **후순위의 포트가 백업 포트로 결정**된다. 즉, 동일한 세그먼트 내의 **하나의 스위치에서 2개 이상의 링크**가 접속되어 있을 때 **백업 포트**가 생성되며, 데이터 프레임을 송/수신 하지 않고 **차단 상태**로 있게된다.

### 포트의 상태 정의

RSTP는 Port 의 상태를 '**폐기(Blocking), 학습(Learning), 전송(Forwarding)**' 상태로 구분한다.

#### 폐기(Blocking)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     X     |
|  데이터 전송  |     X     |

STP의 차단(Blocking)과 동일하며, 데이터 프레임을 송/수신 하지 않고 **차단**하며 **BPDU만 수신** 한다.

#### 학습(Learning)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     O     |
|  데이터 전송  |     X     |

STP의 학습(Learning)과 동일하며, MAC 주소 테이블을 채우기 시작하며, 지정 포트일 경우 BPDU를 전송한다. STP와는 다르게 **전송 지연 타이머가 매우 짧다.**

#### 전송(Forwarding)

|     항목      | 가능 여부 |
| :-----------: | :-------: |
| BPDU 송/수신  |     O     |
| MAC 주소 학습 |     O     |
|  데이터 전송  |     O     |

STP의 전송(Forwarding)과 동일하며, 데이터 프레임을 정상적으로 송/수신 하기 시작한다.

#### STP와 RSTP의 포트 역할과 상태 차이점

![image](https://user-images.githubusercontent.com/50439622/147316204-21be835a-520b-463e-a936-4b9042fa4ebb.png)

**루트 포트**와 **지정 포트**는 STP, RSTP 둘다 동일 하다. STP에서는 블락되어있는 포트를 **non-designated port(이하 지정되지 않은 포트)** 라고 하고 RSTP에서는 **alternative port(이라 대체 포트)**  또는 **backup port(이하 백업 포트)** 라고 한다. 대체 포트와 백업 포트는 차이가 존재한다. STP의 지정되지 않은 포트를 RSTP에서는 **대체 포트**라고 보면 된다. 즉, **장비간의 비교를 했을 때 우선 순위에서 밀려서 블락이 된 포트**를 말한다. RSTP에서 말하는 **백업 포트**는 허브 연결과 같이 이중 연결 할때 루프를 돌게 되니까 한 선은 블락되야 하는데, **우선 순위가 밀려서 블락된 포트**를 말한다. 이 포트들의 특징인 **blocking**은 STP에서만 그렇게 부르고 RSTP에서는 **discarding**이라고 한다. 그리고 STP와 RSTP의 비활성 포트는 링크가 다운된 상태를 말한다. STP는 청취 상태 - 학습 상태 - 전송 상태 의 순서와 비교적 긴 시간을 갖는데, **RSTP는 학습 상태 - 전송상태** 의 짧은 시간을 갖는다.

### Root Bridge 선택 기준

![image](https://user-images.githubusercontent.com/50439622/147178984-abbe9fd8-b8f7-435f-88bc-8f249c38e7cc.png)

- Bit 1 : Proposal BPDU가 전송하는 Port가 Designated Port 로 동작하겠다는 것을 제안할 때 사용한다.
- Bit 2-3 : Port 역할에 대한 표시
                00(미정), 01(대체 Port), 10(Root Port), 11(Designated Port)
- Bit 4 : Learning Status
- Bit 5 : Forwarding Status
- Bit 6 : 상대가 송신했던 Proposal BPDU를 수신한 포트가 그 제안을 동의해서 Root Port로 동작하겠다고 답장할 때 사용



### 동작 원리  1(초기 구성)

![image](https://user-images.githubusercontent.com/50439622/147187887-66cb524c-fa4f-40b4-bc7d-be1c2d6c5d03.png)

**루트 스위치** 선출과 같은 경우 STP 와 동일하다. 루트 스위치인 SW1은 SW2와 SW3에게 각각 **Proposal BPDU**를 송신한다. Proposal BPDU를 송신하는 Port는 항상 **지정 포트**이며, BPDU를 송신하는 동시에 **바로 지정포트의 역할**을 하게된다. SW2와 SW3은 루프가 도는것을 방지하기 위해 Proposal BPDU를 수신한 Port를 제외한 모든 Port를 **차단**한다. 또한 SW2와 SW3은 SW1과 연결된 Port들을 **루트 포트**로 사용하겠다는 **Agreement BPDU**를 SW1에게 송신함과 동시에 **루트 포트**로 변경 및 **전송상태**로 변경한다. **Agreement BPDU**를 수신한 SW1은 모든 Port를 **전송상태**로 변경한다. 위의 그림에서 SW2와 SW3의 관계를 보면 BID가 낮은 SW2의 Fa0/2가 **지정 포트** 역할을 하게 된다. SW3의 경우 Fa0/2는 **대체 포트**가 되고, **루트 포트**가 아니므로 **Agreement BPDU**를 송신할 수 없다. SW2의 경우 Fa0/2는 **지정 포트**이므로 **Proposal BPDU**를 SW3에게 송신하게 된다. SW2는 **Agreement BPDU**를 받지 못하며 차단상태(STP에서 청취 상태에 해당)에서 15초 동안 계속 BPDU를 전송한다. 15초 동안 응답이 없으면 학습 상태로 변경되며 이 상태에서도 15초 동안 BPDU를 전송하며 15초 후에 전송상태로 변경된다.

![image-20211223134457195](C:\Users\hdn\AppData\Roaming\Typora\typora-user-images\image-20211223134457195.png)

새로운 BPDU를 받으면 다른 스위치와의 연결을 블락하고 자신이 알고 있는 기존의 루트와 비교 후에 기존의 루트 스위치보다 더 좋은 정보라면 바로 루트 포트로 만든다. 나머지 스위치에게 새로운 루트에 대한 정보를 주면서 **자신을 루트포트로 삼지 않겠냐는 제안을 한다. 정보를 수집 (STP의 청취 상태) 하는 것이 아닌 Hop-by-Hop으로 새로운 루트 정보를 전달하며 동기화 하는 것이 RSTP의 핵심이다.**

### 동작 원리 2 (장애 발생)

![image-20211223135022147](C:\Users\hdn\AppData\Roaming\Typora\typora-user-images\image-20211223135022147.png)

![image-20211223135102391](C:\Users\hdn\AppData\Roaming\Typora\typora-user-images\image-20211223135102391.png)

STP인 경우 SW2로 부터 후순위 BPDU를 SW3이 10번 받으면서 (Defailt Age-Max 20Sec) 20초를 기다리고, Listening - Learning - Forwarding 까지 **50초 소요**된다.

RSTP인 경우 SW3은 SW2가 송신한 후순위 BPDU 수신 시 자신의 Fa0/2는 응답으로 Agreement BPDU를 보내고 이를 수신한 SW3의 Fa0/2 Port는 즉시 Blocking - Forwarding 으로 변경된다. **(이 변경 시간이 단 1초도 걸리지 않음)**

## MSTP (Multiple Spanning Tree Protocol) - IEEE 802.1s



