## 목차

1. [Netconf(Network Configuration Protocol)](#1-netconfnetwork-configuration-protocol)<br>1.1 [Netconf Overview](#11-netconf-overview)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1.1 [what's NETCONF?](#111-whats-netconf)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1.2 [what's RPC (Remote Procedure call) ?](#112-whats-rpc-remote-procedure-call-)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.1.3 [what's YANG?](#113-whats-yang)<br>1.2 [RFC 6241:NETCONF (Network Configuration Protocol)](#12-rfc-6241netconf-network-configuration-protocol)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.1 [용어정리](#121-용어정리)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.2 [Netconf 프로토콜](#122-netconf-프로토콜)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.3 [NETCONF Layer 구조](#123-netconf-layer-구조)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.4 [Transport Protocol Requirements](#124-transport-protocol-requirements)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.5 [RPC Model](#125-rpc-model)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.6 [Configuration Model](#126-configuration-model)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.7 [Subtree Filtering](#127-subtree-filtering)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.8 [Protocol Operations](#128-protocol-operations)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.9 [Capabilities](#129-capabilities)<br>1.3 [RFC 6020:YNAG-A Data Modeling Language for the Network Configuration Protocol(NETCONF)](#13-rfc-6020yang-a-data-modeling-language-for-the-network-configuration-protocolnetconf)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3.1 [Language Overview](#131-language-overview)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3.2 [Language Concepts](#132-language-concepts)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.3.3 [YANG Statements](#133-yang-statements)<br>
2. [libnetconf2 / libyang 이용](#2-libnetconf2--libyang-이용)<br>2.1 [사용 라이브러리](#21-사용-라이브러리)<br>2.2 [How to Configure the NETCONF Protocol(Cisco)](#22-how-to-configure-the-netconf-protocolcisco)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1 [Providing Privilege Access to Use NETCONF](#221-providing-privilege-access-to-use-netconf)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2 [Configuring NETCONF-YANG](#222-configuring-netconf-yang)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3 [Configuring NETCONF Options (CISCO IOS 기반)](#223-configuring-netconf-options-cisco-ios-기반)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.4 [Verifying the NETCONF Protocol Configuration](#224-verifying-the-netconf-protocol-configuration)<br>
3. [YumaPro SDK INSTALLATION](#3-yumapro-sdk-installation)<br>3.1 [Installing YumaPro SDK](#31-installing-yumapro-sdk)<br>3.2 [External Package Needed by the Server](#32-external-package-needed-by-the-server)<br>3.3 [External Packages Needed by the Client](#33-external-packages-needed-by-the-client)<br>3.4 [YumaPro Packages](#34-yumapro-packages)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4.1 [Start the netconfd-pro server](#341-start-the-netconfd-pro-server)<br>3.5 [Configure SSH](#35-configure-ssh)<br>3.6 [Start netconfd-pro](#36-start-netconfd-pro)<br>3.7 [yangcli-pro Connect](#37-yangcli-pro-connect)<br>3.8 [Configure TLS](#38-configure-tls)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.1 [Server Setup](#381-server-setup)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.2 [Client Setup](#382-client-setup)<br>3.9 [Enable Notification Delivery](#39-enable-notification-delivery)<br>3.10 [Load the Toaster Module](#310-load-the-toaster-module)<br>3.11 [Enable the Toaster](#311-enable-the-toaster)<br>3.12 [Get the Toaster State Information (GET Test)](#312-get-the-toaster-state-information-get-test)<br>3.13 [Start/Stop Making Toast (notification Test)](#313-startstop-making-toast-notification-test)<br>
4. [YumaPro SDK Advanced Topics](#4-yumapro-sdk-advanced-topics)<br>4.1 [Data Retrieval](#41-data-retrieval)<br>4.2 [Notifications](#42-notifications)<br>4.3 [Database Editing](#43-database-editing)<br>4.4 [System Configuration](#44-system-configuration)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4.1 [Environment Variables](441-environment-variables)<br>
5. [OpenYuma Developmet Manual](#5-openyuma-developmet-manual)<br>5.1 [What is a OpenYuma Root?](#51-what-is-a-openyuma-root)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1 [Searching OpenYuma Roots](#511-searching-openyuma-roots)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2  [What is a SIL ?](#512-what-is-a-sil-)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.3 [Basic Development Steps](#513-basic-development-steps)<br>5.2 [Server Design](#52-server-design)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 [YANG Native Operation](#521-yang-native-operation)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 [Server Message Flows](#522-server-message-flows)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3 [Main ncxserver Loop](#523-main-ncxserver-loop)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.4 [SIL Callback Functions](#524-sil-callback-functions)<br>5.3 [Programs and Libraries Needed](#53-programs-and-libraries-needed)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.1 [SIL Shared Libraries](#531-sil-shared-libraries)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.2 [SIL Library Names](#532-sil-library-names)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.3 [SIL Library Location](#533-sil-library-location)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.4 [make_sil_dir](#534-make_sil_dir)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.5 [Basic YANG Module Structure](#535-basic-yang-module-structure)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3.6 [Identifiers in YANG Modules](#536-identifiers-in-yang-modules)<br>
6. [OpenYuma OpenSource Installation]<br>6.1 [External Package Needed by the Server]<br>6.2 [External Packages Needed by the Client]<br>6.3 [Configure SSH]<br>6.4 [Start netconfd]<br>6.5 [yang cli Connect]<br>

# 1. Netconf(Network Configuration Protocol)

NETCONF Program 개발하기 전 NETCONF의 개념과 동작 방식에 대한 숙지가 필요하다고 생각된다. NETCONF 기반 기술과 그와 관련된 RFC 문서를 통해 구체적인 NETCONF / YANG에 대한 내용을 정리하였다. 

## 1.1 Netconf Overview

### 1.1.1 what's NETCONF?

- IETF에서 개발하고 표준화 한 네트워크 관리 프로토콜
- NETCONF 프로토콜 사양은 인터넷 표준 추적 문서 (NETCONF -> RFC : 6241, YANG -> RFC : 6020)
- NETCONF는 네트워크 장치의 구성을 설치, 조작 및 삭제하는 메커니즘을 제공 - 이 작업은 RPC(원격 프로시저 호출) 계층에서 구현됨.
- NETCONF는 TCP/SSH 위에서 정의되는 응용 계층 프로토톨로 주로 xml 형식과 그 형식에 따른 동작에 대한 내용이 주가 됨. 



### 1.1.2 what's RPC (Remote Procedure call) ?

-  RPC(Remote Procedure call)이란, **별도의 원격 제어를 위한  코딩 없이 다른 주소 공간에서 리모트의 함수나 프로시저를 실행 할 수 있게 해주는 프로세스간 통신**이다. 즉, 위치에 상관없이 RPC를 통해 개발자는 원하는 함수를 사용할 수 있다.
   RPC는 IPC(Inter-Process Communication) 방법의 한 종류로 원격지의 프로세스에 접근하여 프로시저 또는 함수를 호출하여 사용하는 방법을 말한다.
   
   ![image](https://user-images.githubusercontent.com/50439622/99014139-79474200-2595-11eb-88cf-3033af02349c.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림1. RPC 데이터 request/response 개념

1. IDL(Interface Definition Language) 을 사용하여 서버의 호출 규약을 정의한다.
   - 함수명, 인자, 반환값에 대한 데이터형이 정의된 IDL 파일을 rpcgen 컴파일러를 이용하여 stub 코드를 자동으로 생성한다,
2. stub는 원시소스코드(c코드 등) 형태로 만들어지므로 클라이언트, 서버 프로그램에 포함하여 빌드한다.
3. 클라이언트 프로그램 입장에서 자신의 프로세스 주소공간의 함수를 호출하는 것과 동일하게 stub에 정의된 함수를 호출할 수 있게 된다.
4. stub 코드는 데이터형을 XDR(eXtrenal Data Representation) 형식으로 변환하여 RPC 호출을 실행한다.
   - XDR 변환 이유는 기본 데이터 타입(정수형, 부동소수점 등)에 대한 메모리 저장방식(리틀엔디안, 빅엔디안)이 CPU 아키텍처 별로 다르며, 네트워크 전송과정에서 바이트 전송 순서를 보장하기 위함이다.
5. 서버는 수신된 함수/프로시저 호출에 대한 처리 완료 후, 결과값을 XDR 변환하여 반환한다.
6. 최종적으로 클라이언트 프로그램은 서버의 결과값을 반환받는다.



### 1.1.3 what's YANG?

```
YANG(yet another next generation)은 IETF에서 표준화한 데이터 모델링 언어로 NETCONF로 전달하기 위한
데이터의 모델링을 위해 사용한다. RFC 6020에서는 YANG 자체의 구조와 선언, 타입에 대한 정의를 한다.
예를 들어, 다음과 같은 NETCONF XML 데이터를 만들기 위한 데이터 모델링을 정의한다.
```

![image](https://user-images.githubusercontent.com/50439622/99022499-3477d700-25a6-11eb-92dd-98e3fec3d61f.png)
![image](https://user-images.githubusercontent.com/50439622/99022519-3c377b80-25a6-11eb-848a-cbd55f1fad7b.png)

```
위의 예시처럼 각 프로토콜 별로 그에 맞는 데이터 모델을 YANG 형식으로 정의해야 한다.
(like SNMP MIB)
```

```
네트워크 관리 프로토콜 SNMP 가 존재. UDP 기반, MIB 기반의 데이터 모델이 장비 설정 관리에 효율적이지
못하다는 단점이 존재.

클라우드, SDN(Software defined Network), NFV(Network function Virtualization) 같은 기존 HW 기반
on-premise 중심에서 탈피한 새로운 개념의 네트워크 환경이 대두되면서, 관리가 필요한 네트워크 노드의 수와
종류가 비교할 수 없이 커지고 네트워크 설정의 자동화의 필요성이 높아졌다. NETCONF, YANG은 이러한 환경에
적합한 네트워크 관리 프로토콜로 정의되었다.
```



## 1.2 RFC 6241:NETCONF (Network Configuration Protocol)

```
네트워크 장치의 구성을 설치, 조작 및 삭제하는 메커니즘을 제공. 구성 데이터 및 프로토콜 메시지에 대해
XML(Extensible Markup Language) 기반 데이터 인코딩을 사용함. NETCONF 프로토콜 작업은 
RPC(원격 프로시저 호출)로 실현됨. RFC4741 더이상 사용 안함(폐기)
```

### 1.2.1 용어정리

- datastore : 정보를 저장하고 액세스하기 위한 개념적 장소. 예를 들어 파일, 데이터베이스, 플래시 메모리 위치 또는 데이터 조합을 사용하여 데이터스토어를 구현할 수 있다.
- candidate configuration datastore : 디바이스의 현재 구성에 영향을 주지 않고 조작할 수 있으며 실행 중인 구성 데이터스토어에 커밋할 수 있는 구성 데이터스토어. 모든 디바이스가 후보 구성 데이터스토어를 지원하는 것은 아니다.
- configuration datastore : 초기 기본 상태에서 원하는 작동 상태로 디바이스를 가져오는 데 필요한 전체 구성 데이터 집합을 포함하는 데이터스토어.
- running configuration datastore : 디바이스에서 현재 활성 상태인 전체 구성을 유지하는 구성 데이터스토어. 실행 중인 구성 데이터스토어가 항상 존재함
- startup configuration datastore : 디바이스가 부팅될 때 로드된 구성을 유지하는 구성 데이터스토어. 시작 구성 데이터스토어와 실행 중인 구성 데이터스토어를 구분하는 디바이스에만 표시됨.
- configuration data : 시스템을 초기 기본 상태에서 현재 상태로 변환하는 데 필요한 쓰기 가능 데이터 집합.
- state data : 읽기 전용 상태 정보 및 수집된 통계와 같은 구성 데이터가 아닌 시스템의 추가 데이터.
- capability : 기본 NETCONF 사양을 보완하는 기능.
- message : 세션을 통해 전송된 프로토콜 요소. 메시지는 제대로 구성된 XML 문서
- notification : 서버에서 특정 이벤트를 인식했음을 나타내는 서버 시작 메시지.
- protocol operation : NETCONF 프로토콜 내에서 사용되는 특정 원격 프로시저 호출.

### 1.2.2 Netconf 프로토콜

관련 docs : http://www.netconfcentral.org/netconf_docs

![image](https://user-images.githubusercontent.com/50439622/99017766-f675b580-259b-11eb-8e2e-a7397b9c6398.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림2. NETCONF Conceptual Layers

- Netconf 프로토콜은 개념적으로 4개의 계층으로 분할 될 수 있다.
  1. Content 계층 : 구성 데이터와 알림 데이터로 구성
  2. Operations 계층 : 운영 계층은 XML 인코딩 매개변수를 가진 RPC 메서드로 호출된 일련의 기본 프로토콜 작업을 정의
  3. Message 계층 : 메시지 계층은 RPC와 notification을 인코딩하기 위한 간단하고 전송에 독립적인 프레임 메커니즘을 제공
  4. Secure Transport 계층 : 보안 전송 계층은 클라이언트와 서버 사이의 통신 경로를 제공. 클라이언트와 클라이언트 간에 안전하고 안정적인 메시지 전송 제공
  
- YANG 데이터 모델링 언어[RFC6020]는 Operations 및 Content 계층을 망라하여 NETCONF 데이터 모델 및 프로토콜 운영을 명시하기 위해 개발되었다.

  **1. Configuration Database**

  ![image](https://user-images.githubusercontent.com/50439622/101708268-3f078c80-3ad0-11eb-8bc0-a8431dcbf565.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림3. configuration database load 방법 및 절차

  NETCONF 프로토콜에는 하나 이상의 개념적 Configuration Database에서 작동하는 여러 표준 작업이 포함되어 있다. 예를 들어 < edit-config > 작업에 대한 < target > parameter는 edit 할 database를 지정한다.

  Configuration database는 NETCONF 작업 내에서 표준 데이터베이스를 식별하는 빈 요소 또는 비표준 데이터베이스를 식별하는 < url > 요소로 표시된다(in XML)

  3가지의 표준 개념 Configuration database

  - **< running/ >**

    Running database는 현재 장치 내에 있는 전체 활성화 구성을 나타낸다. 유일한 필수 표준 데이터베이스.<br />서버가 **:candidate** 기능을 지원하지 않는 한 서버는 이 데이터베이스를 직접 편집할 수 있도록 허용해야 한다. 그렇지 않으면 서버가 이 데이터베이스를 직접 변경하는 것을 지원할 필요가 없다. 지원하는 경우 서버에서 **:writable-running** 기능을 광고하여 지원을 표시

    **< running/ >** 데이터베이스는 현재 장치에서 사용할 수 있는 모든 개념적 상태 정보를 포함하는데도 사용됨.<br />**< get >**과 같은 작업은 구성 매개변수 외에도 상태 정보 및 통계를 검색할 수 있다.<br />**< get-config>** 작업을 사용하여 구성 데이터만 검색 할 수 있다.

    

  - **< candidate/ >**

    서버에서 **:candidate** 기능을 지원하는 경우 사용가능.<br/>**< edit-config>** 작업을 통해 편집 내용을 수집하는데 사용되는 전역 스크래치 패드 데이터베이스이다.

    **< ruinning />** 데이터베이스와 달리 **< candidate /> 데이터베이스에 대한 변경 사항은 네트워크 장치 내에서 즉시 적용되지 않는다.**

     **< commit >** 작업을 사용하여 **< candidate />** 데이터 베이스에 구현된 변경 사항을 활성화 하고 **< running />** 데이터베이스 구성의 일부로 만들 수 있다.

    **< commit >** 작업이 성공하면 **< candidate />** 데이터베이스와 **< running >** 데이터베이스의 구성 내용이 동일.<br/>**< commit >** 작업 전 **< lock >**작업이 수행되어야 한다.(< runnning > 데이터베이스와 다르면 잠글 수 없음 ==> 여러 세션이 동시에 데이터베이스를 편집하지 않도록 **lock**사용됨) 또한 어떤 세션(client)이 **< candidate />** 데이터베이스를 변경하는지는 중요하지 않다.  

    **< commit >**작업이 사용되지 않을 경우 **< discard-changes >** 작업을 사용하여 원하지 않는 변경 사항을 제거.

    ※ **:candidate** 기능을 지원하는 서버 플랫폼은 일반적으로 **:writable-running** 기능을 지원하지 않는다.<br/>**< running />**에 대한 직접 편집을 함께 사용하면 **< candidate/ >**를 사용하여 변경 사항을 적용하기 전에 수집하고 유효성을 검사하는 목적이 무효화 되기 때문이다.

  - **< startup/ >**

    서버에서 **:startup** 기능을 지원하는 경우 사용 가능.<br/>장치를 재부팅할 때 사용할 Configuration을 나타낸다.

    서버는 non-volatile 저장소의 **< running />** 데이터베이스에 대한 변경 사항을 자동으로 저장하지 않는다. 대신 **< startup />** 데이터베이스의 내용을 현재 구성으로 덮어 쓰려면 **< copy-config >** 작업이 필요하다.

    **< startup />** 데이터베이스가 존재하지 않는 경우 서버는 실행중인 구성이 수정 될 때마다 non-volatile 저장소를 자동으로 업데이트 해야한다.

    **< startup />** 데이터베이스가 존재하든 존재하지 않든 실행중인 구성의 non-volatile 저장소를 유지해야 하며, 재부팅 후 실행중인 구성을 복원할 수 있어야 한다.

  **2. Editing the Configuration**

  NETCONF 편집 작업을 사용하기 전에 클라이언트는 세션 설정 중에 서버에서 보낸 기능을 검사하여 대상으로 사용할 데이터베이스를 결정

  ```xml
  if ':candidate' capability supported:
    target = <candidate/>
  else if ':writable-running' capability supported:
    target = <running/>
  else if ':url' capability supported:
    target = <url>file://path/to/file</url>
  else:
    target = None     #  Server is non-complaint
  
  ```

  편집작업의 대상이 결정되면 클라이언트는 구성 변경 사항을 적용하는데 필요한 **'activate'** 작업을 결정

  ```xml
  if ':candidate' capability supported:
    if ':confirmed-commit' capability supported and desired:
      if default timeout of 600 seconds desired:
         activate_fn =  <commit>
                        <confirmed/>
                        </commit>
      else:
         activate_fn =  <commit>
                        <confirmed/>
                        <confirm-timeout>300</confirm-timeout>
                        </commit>
    else:
            activate_fn =  <commit/>
  else 
     activate_fn = None     #  <running/> or <url> target
  ```

  **'target'** 및 **activate function**이 결정된 후 client는 활성화 된 구성 변경 사항을 non-volatile 저장소에 저장되는 방법을 경정

  ```xml
  if ':startup' capability supported:
    save_fn =  <copy-config>
               <target><startup/></target>
               <source><running/></source>
               </copy-config>
  else 
    save_fn = None     #  automatic NV-updat
  ```

  - **Candidate Configuration Example**

    1. lock **< running/ >** database

    2. lock **< candidate/ >** database

    3. edit **< candidate/ >** database

    4. commit **< candidate/ >** database

    5. unlock **< candidate/ >** database

    6. unlock **< running/ >** database

    ```xml
    <!-- 1. lock <running/> -->
    <rpc message-id="101" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <lock>
        <target><running/></target>
      </lock>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- 2. lock <candidate/> -->
    <rpc message-id="102" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <lock>
        <target><candidate/></target>
      </lock>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- 3. edit <candidate/> -->
    <rpc message-id="103" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <edit-config>
        <target><candidate/></target>
        <default-operation>none</default-operation>
        <test-option>test-then-set</test-option>
        <error-option>stop-on-error</error-option>
        <nc:config 
            xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"
            xmlns="uri-for-my-data-model-namespace">
      <some-existing-node>
         <my-new-node nc:operation="create">
           <my-new-leaf>7</my-new-leaf>
         </my-new-node>
      </some-existing-node>
        </nc:config>
      </edit-config>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- 4. commit <cancidate/> -->
    <rpc message-id="104" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <commit/>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- 5. unlock <candidate/> -->
    <rpc message-id="105" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <unlock>
        <target><candidate/></target>
      </unlock>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- 6. unlock <running/> -->
    <rpc message-id="106" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <unlock>
        <target><running/></target>
      </unlock>
    </rpc>
    
    # server returns <ok/> status
    ```

    

  - **Running + Startup Configuration Example**

    1. lock **< running/ >** database

    2. lock **< startup/ >** database

    3. edit **< running/ >** database

    4. copy **< running/ >** database to <startup/> database

    5. unlock **< startup/ >** database

    6. unlock **< running/ >** database

    ```xml
    <!-- 1. lock <running/> -->
    <rpc message-id="107" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <lock>
        <target><running/></target>
      </lock>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- 2. lock <startup/> -->
    <rpc message-id="108" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <lock>
        <target><startup/></target>
      </lock>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- 3. edit <running/> -->
    <rpc message-id="109" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <edit-config>
        <target><running/></target>
        <default-operation>none</default-operation>
        <test-option>test-then-set</test-option>
        <error-option>rollback-on-error</error-option>
        <nc:config 
            xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0"
            xmlns="uri-for-my-data-model-namespace">
      <some-existing-node>
         <my-new-node nc:operation="create">
           <my-new-leaf>7</my-new-leaf>
         </my-new-node>
      </some-existing-node>
        </nc:config>
      </edit-config>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- copy <running/> -->
    <rpc message-id="110" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <copy-config>
        <target><startup/></target>
        <source><running/></source>
      </copy-config>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- unlock <startup/> -->
    <rpc message-id="111" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <unlock>
        <target><startup/></target>
      </unlock>
    </rpc>
    
    # server returns <ok/> status
    
    <!-- unlock running/> -->
    <rpc message-id="112" 
      xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <unlock>
        <target><running/></target>
      </unlock>
    </rpc>
    
    # server returns <ok/> status
    ```

    

### 1.2.3 NETCONF Layer 구조

![image](https://user-images.githubusercontent.com/50439622/99021400-f083d280-25a3-11eb-8a55-c79b0c29904d.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림4. NETCONF Layer 구조와 example

- example 기준으로 설명.
  "rpc" 태그는 message 단위를 정의한다. 이외에 그 응답인 "rpc-reply"와 이벤트 발생 시 그 알림을 위한
  "notofication"이 있다. 그 내부의 "edit-config"는 message로 전달하고자 하는 동작의 종류를 정의한다.

```
※ Operations 동작 종류
- <get> : 현재 사용 중인 설정 및 장치 상태 정보를 요청
- <get-config> : configuration datastore (netconf에서의 configuration set 단위) 를 요청

-- get / get-config 차이점 --
| 실행 중인 시스템에서 검색할 수 있는 정보는 configuration data와 state data라는 두가지 클래스로 구분됨.
| configuration data는 시스템을 초기 기본 상태에서 현재 상태로 변환하는 데 필요한 쓰기 가능한 데이터 집합
| state data는 읽기 전용 상태 정보 및 수집된 통계와 같은 구성 데이터가 아닌 시스템의 추가 데이터
| get-config 작업은 configuration data 만 검색, <get> 작업은 configuration 및 state data를 검색.

- <edit-config> : 내용 편집
- <copy-config> : 다른 datastore로 복사
- <delete-config> : 삭제 요청
- <lock>, <unlock> : configuration datastore 수정 앞뒤로 lock/unlock을 건다
- <close-session> : NETCONF session을 절차적으로 종료
- <kill-session> : 기타 다른 문제 등으로 인해 강제 종료
```

그 내부 계층에는 YANG 형식으로 정의된 content가 "config" ... ""/config" 태그로 싸서 들어가게 된다.

### 1.2.4 Transport Protocol Requirements

1. **Connection-Oriented Operation (연결 지향적 작동)**
   **NETCONF는 연결 지향적이므로 피어 간의 지속적인 연결이 필요**하다. 이 연결은 반드시 신뢰할 수 있고 서열화된 데이터 전송을 제공해야 한다. NETCONF 연결은 프로토콜 운영 간에 지속되는 장기적 연결이다.

   또한 특정 연결을 위해 서버에서 요청된 자원은 연결이 닫힐 때 자동으로 해제되어야 하므로 장애 복구는 더욱 간단하고 강력해야 한다. 예를 들어 클라이언트가 잠금을 취득한 경우 잠금은 명시적으로 해제되거나 서버가 연결이 종료되었다고 판단할 때까지 계속된다. 클라이언트가 잠금을 잡고 있는 동안 연결이 종료되면 서버는 적절한 복구를 수행할 수 있다.

2. **Authentication, Integrity, Confidentiality (인증, 무결설, 기밀성)**
   NETCONF 연결은 인증, 데이터 무결성, 기밀성 및 재생 보호를 제공해야 한다. NETCONF는 이 기능에 대한 전송 프로토콜에 의존한다. NETCONF 피어는 적절한 수준의 보안과 기밀성이 이 문서와 독립적으로 제공된다고 가정한다. 예를 들어, 기본 프로토콜에 따라 **TLS(Transport Layer Security)[RFC5246] 또는 SSH(Secure Shell)[RFC4251]를 사용하여 연결을 암호화**할 수 있다.

   NETCONF 연결은 반드시 인증되어야 한다. 전송 프로토콜은 클라이언트에 대한 서버 인증과 서버에 대한 클라이언트의 인증을 책임진다. NETCONF 피어는 충분히 신뢰할 수 있는 메커니즘을 사용하여 기본 전송 프로토콜에 의해 연결의 인증 정보가 검증되었고 피어의 정체성이 충분히 입증되었다고 가정한다.

   NETCONF의 한 가지 목표는 장치의 기본 인터페이스의 기능을 근접하게 따르는 장치에 프로그래밍 방식의 인터페이스를 제공하는 것이다. 따라서, 기본 프로토콜은 단말기에서 이용 가능한 기존의 인증 메커니즘을 사용할 것으로 예상된다. 예를 들어 **RADIUS [RFC2865]를 지원하는 장치의 NETCONF 서버는 RADIUS를 사용하여 NETCONF 세션을 인증**할 수 있다.

   인증 프로세스는 서버에 권한을 알 수 있는 인증된 클라이언트 ID를 생성해야 한다. 클라이언트의 인증된 ID는 일반적으로 NETCONF 사용자 이름으로 불린다. **사용자 이름을 도출하는 데 사용되는 알고리즘은 전송 프로토콜에 특정**한다. 전송 프로토콜은 반드시 다른 NETCONF 계층에서 사용할 사용자 이름을 제공해야 한다.

   NETCONF 사용자 이름으로 식별되는 주어진 클라이언트의 액세스 권한은 NETCONF 서버 구성의 일부이다. 이러한 권한은 NETCONF 세션의 나머지 기간 동안 시행되어야 한다. 

3. **Mandatory Transport Protocol (필수 전송 프로토콜)**
   **NETCONF 구현은 SSH 전송 프로토콜 매핑을 지원**해야한다.

### 1.2.5 RPC Model

NETCONF 프로토콜은 RPC 기반 통신 모델을 사용한다. NETCONF peer들은 "rpc"와 "rpc-reply" 요소를 사용하여 NETCONF 요청 및 응답의 전송 프로토콜 독립적 프레임을 제공한다.

- "rpc" Element
  "rpc" 요소는 **클라이언트에서 서버로 전송**된 NETCONF 요청을 동봉하는 데 사용된다.
  "rpc" 요소에는 **필수 속성인 "message-id"**가 있는데, 이는 RPC의 송신자가 선택한 문자열로서 단조롭게 증가하는 정수를 일반적으로 인코딩하게 된다. RPC의 수신기는 이 문자열을 해독하거나 해석하지 않고 단순히 저장하여 결과적인 "rpc-reply" 메시지에서 "message-id" 속성으로 사용되도록 한다. 송신자는 반드시 [W3C]에 정의된 XML 속성 값 정규화 규칙에 따라 "메시지 ID" 값이 정규화되도록 해야 한다.
  관련 문서 : https://www.w3.org/TR/2000/REC-xml-20001006

  ````xml
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <some-method>
          <!-- method parameters here... -->
      </some-method>
  </rpc>
  ````

  추가 속성이 "rpc" element에 존재하는 경우, NETCONF peer는 반드시 "rpc-reply" element에서 수정되지 않은 속성을 반환해야 한다. 여기에는 모든 "xmlns" 속성이 포함된다.
  RPC의 명칭과 파라미터는 "rpc" element의 내용으로 인코딩된다. RPC의 명칭은 "rpc" 요소 바로 안쪽에 있는 요소로서, 어떤 파라미터든 이 요소 안쪽에 인코딩되어 있다.

  ```xml
  <!-- ex 1) a <rock-the-house> method with a <zip-code> parameter of "27606-0100" -->
  <rpc message-id="101"
        xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
       <rock-the-house xmlns="http://example.net/rock/1.0">
           <zip-code>27606-0100</zip-code>
       </rock-the-house>
  </rpc>
  
  <!-- ex 2) the NETCONF <get> method with no parameters -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <get/>
  </rpc>
  ```

  

- "rpc-reply" element

  "rpc-reply" 메시지는 "rpc" 메시지에 대한 응답으로 보내진다.
  "rpc-reply" element는 필수 속성인 "message-id"를 가지고 있는데, 이것은 응답인 "rpc"의 "message-id" 속성과 같다.
  또한, NETCONF 서버는 **"rpc-reply" element에서 수정되지 않은 "rpc"  element에 포함된 추가 속성을 반드시 반환**해야 한다.

  

  The response data is encoded as one or more child elements to the "rpc-reply" element.

  ```xml
  <!-- ex) <rpc> element는 NETCONF의 <get> 호출을 하며, "user-id"라는 추가 속성을 포함함.
   		반환된 <rpc-reply> 요소는 요청된 내용뿐만 아니라 "user-id" 속성도 반환함.
  		※ "user-id" 속성은 NETCONF 네임스페이스에 있지 않다는 점에 유의. -->
      
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:ex="http://example.net/content/1.0"
       ex:user-id="fred">
      <get/>
  </rpc>
  
  <rpc-reply message-id="101"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
             xmlns:ex="http://example.net/content/1.0"
             ex:user-id="fred">
      <data>
          <!-- contents here... -->
      </data>
  </rpc-reply>
  ```

  

- "rpc-error" element
  "rpc-error" element는 **"rpc" 요청 처리 중 에러가 발생하면 "rpc-response" 메시지로 전송**된다.

  서버가 "rpc" 요청을 처리하는 동안 복수의 오류가 발생하는 경우, "rpc-reply"에는 복수의 "rpc-error" element가 포함되어 있을 수 있다. 
  단, 
  
  **1. 요청에 여러 개의 오류가 포함된 경우, 서버는 하나 이상의 "rpc-error" element를 탐지하거나 보고할 필요가 없다.** 
**2. 서버는 특정 오류 조건을 특정 순서로 확인할 필요가 없다.** 
  **3. 서버는 처리중 오류 조건이 발생하면 반드시 "rpc-error" element를 반환**해야 한다.
  
  ```
  1. error-type : 오류가 발생한 개념 계층을 정의한다.
  *  transport (layer: Secure Transport)
  *  rpc (layer: Messages)
  *  protocol (layer: Operations)
  *  application (layer: Content)
  
  2. error-tag : 오류 상태를 식별하는 문자열이 들어있음 
  (https://tools.ietf.org/html/rfc6241#appendix-A 참고)
  
  3. error-severity : 장치에 의해 결정된 오류 심각도를 식별하는 문자열이 들어있다.
  *  error
  *  warning
  
  4. error-app-tag : 데이터 모델별 또는 구현별 오류 조건을 식별하는 문자열을 포함.
  
  5. error-path
  
  6. error-message
  
  ```
7. error-info : 프로토콜 또는 데이터 모델별 오류 콘텐츠 포함.
  ```
  
  ```xml
  <!-- ex "message-id" 속성 없이 <rpc> 요소를 수신하면 오류가 반환된다. 
  	이 경우에만 NETCONF 피어가 <rpc-reply> 요소에서 "message-id" 속성을 생략할 수 있다는 점에 유의
  -->
  <rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <get-config>
          <source>
              <running/>
          </source>
      </get-config>
  </rpc>
  
  <rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <rpc-error>
          <error-type>rpc</error-type>
          <error-tag>missing-attribute</error-tag>
          <error-severity>error</error-severity>
          <error-info>
              <bad-attribute>message-id</bad-attribute>
              <bad-element>rpc</bad-element>
          </error-info>
      </rpc-er\ror>
</rpc-reply>
  ```

  

- "ok" Element

  "rpc" 요청 처리 중 오류나 경고가 발생하지 않는 경우, operation에서 데이터가 반환되지 않은 경우 "ok" element가 "rpc-reply" 메시지로 전송된다.

  ```xml
  ex)
  <rpc-reply message-id="101"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <ok/>
  </rpc-reply>
  ```

  

- Pipelining

  NETCONF "rpc" 요청은 반드시 관리되는 장치에 의해 연속적으로 처리되어야 한다. 이전의 요청이 완료되기 전에 추가 "rpc" 요청이 전송될 수 있다. 관리되는 장치는 요청을 받은 순서대로만 응답을 전송해야 한다.

### 1.2.6 Configuration Model

- Configuration Datastores

  NETCONF는 하나 이상의 Configuration Datastores의 존재를 정의하고 해당 datastore에서 구성 작업을 허용한다.
  Configuration Datastores는 초기 기본 상태에서 원하는 작동 상태로 디바이스를 가져오는 데 필요한 전체 Configuration Datastores 집합으로 정의된다. Configuration Datastore에는 상태 데이터 또는 실행 명령이 포함되지 않는다.

  실행 중인 Configuration Datastore는 네트워크 디바이스에서 현재 활성 상태인 전체 구성을 유지하며, 디바이스에는 이 유형의 Configuration Datastore가 하나만 있으면 항상 존재한다. **NETCONF 프로토콜 operations는 "running" element를 사용하여 이 Datastore를 참조**한다.

  기본 모델에는 "running" Configuration Datastore만 있다. 추가 Configuration Datastore는 기능에 의해 정의될 수 있다. 이러한 Configuration Datastore는 기능을 보급하는 디바이스에서만 사용할 수 있다.

  

- Data Modeling
  데이터 모델링 및 컨텐츠 문제는 NETCONF 프로토콜의 범위를 벗어난다. device의 데이터 모델이 application에 잘 알려져 있고, 데이터의 layout, containment, keying, lookup, replacement, management와 같은 문제뿐만 아니라 데이터 모델에 의해 부과되는 다른 제약조건에 대해서도 양 당사자가 알고 있다고 가정한다.
  NETCONF는 장치의 데이터 모델에 특정한 구성 데이터를 "config" element 안에 전달한다. 프로토콜은 그 element 내용을 불투명한 데이터로 처리한다. device는 capabilities를 사용하여 device가 구현하는 데이터 모델 집합을 알린다. capabilities definition은 데이터 모델에 의해 부과되는 운영 및 제약사항을 상세히 기술한다.

### 1.2.7 Subtree Filtering

**XML Subtree Filtering은 애플리케이션이 "get" 또는 "get-config" 작업을 위해 "rpc-reply"에 포함할 특정 XML Subtree Filtering을 선택할 수 있는 메커니즘**이다. 서버는 처리 중 데이터 모델별 의미론을 활용할 필요가 없어 단순하고 중앙집중화된 구현 전략이 가능하다.
개념적으로 Subtree Filtering은 필터 선택 기준을 나타내는 0개 이상의 element 하위 트리로 구성된다.

- 하위 트리 필터 구성요소
  하위 트리 필터는 XML 요소와 XML 속성으로 구성된다. 하위 트리 필터에는 다음과 같은 5가지 유형으로 구성요소가 있다.

  1. Namespace Selection
     "filter" element 내의 특정 노드와 연결된 **XML Namespace가 기본 데이터 모델과 동일한 경우 namespace는 (필터 목적으로) 일치하는 것으로 간주**된다. 필터 출력에 element를 포함하려면 필터에 element를 하나 이상 지정해야 한다.
     ※  namespace 선택은 단독으로 사용할 수 없다는 점에 유의.

     XML Namespace 와일드카드 메커니즘은 Subtree Filtering을 위해 정의된다. **"filter" element 내의 element가 Namespace(ex: xmlns="")로 인증되지 않은 경우, 서버는 Subtree Filtering 노드를 처리할 때 지원하는 모든 XML Namespace를 평가**해야 한다.  이 와일드카드 메커니즘은 XML 속성에 적용할 수 없다.

     ※ 필터 요소를 기본 데이터 모델의 요소와 비교할 때 정규화된 Namespace의 접두사 값은 관련이 없다는 점에 유의.

     ```xml
     <filter type="subtree">
         <top xmlns="http://example.com/schema/1.2/config"/> -> top node 내의 네임스페이스 http://...
     </filter>
     ```

     "top" element는 선택 노드로, "http://example.com/schema/1.2/config" namespace에 있는 노드와 (기본 데이터 모델의) 하위 노드만 필터 출력에 포함한다.

     

  2. Attribute Match Expressions
     Subtree filter에 나타나는 속성은 "attribute match expression"의 일부다. 필터 노드 유형에는 임의의 수(비적격 또는 적격) XML 속성이 존재할 수 있다. 일반적으로 해당 노드에 적용할 수 있는 선택 기준 외에도, 선택한 데이터는 노드에 지정된 모든 속성에 대해 일치하는 값을 가져야 한다. 요소가 지정된 속성을 포함하도록 정의되지 않은 경우 필터 출력에서 선택되지 않는다.

     ```xml
     <filter type="subtree">
         <t:top xmlns:t="http://example.com/schema/1.2/config"> -> containment node
             <t:interfaces> -> containment node
                 <t:interface t:ifName="eth0"/> 
                 -> selection node / Attribute Match Expressions "ifName"에 "eth0"값 매핑  
             </t:interfaces>
         </t:top>
     </filter>
     ```

     이 예에서 "top"과 "interfaces" elements는 containment 노드, "interface" element는 선택 노드, "ifName"은 속성 일치 표현식이다. **값이 "eth0"이고 "ifName" 속성이 있으며 "top" -> "interfaces" 노드 내에서 발생하는 "http://example.com/schema/1.2/config" 네임스페이스의 "interface"노드만 출력에 포함됨.**

     

  3. Containment Nodes
     Subtree filter내에 하위 요소를 포함하는 노드를 "containment nodes"라고 한다. 각 하위 요소는 다른 containment node를 포함하여 모든 유형의 노드가 될 수 있다. Subtree filter에 지정된 각 containment node에 대해 *지정된 네임스페이스*, *요소 계층 구조* , *속성 일치 식과 정확히 일치하는 모든 데이터 모델 인스턴스*가 필터 출력에 포함된다.

     ```xml
     <filter type="subtree">
         <top xmlns="http://example.com/schema/1.2/config"> -> containment node
             <users/>
         </top>
     </filter>
     ```

     

  4. Selection Nodes
     **필터 내의 빈 leaf 노드를 "selection node"**라고 하며, 기본 데이터 모델에 대한 "불확실한 선택"필터를 나타낸다. 형제 노드 집합 내에 선택 노드가 있으면 필터는 지정된 하위 트리를 선택하고 기본 데이터 모델에서 전체 형제 노드 집합의 자동 선택을 억제한다. 필터링 목적으로 빈 리프 노드는 빈 태그 (ex: "foo/") 또는 명시적 시작 및 종료 태드 (ex: "foo""/foo") 로 선언할 수 있다. 공백 문자는 이 형식에서 무시된다.

     ```xml
     <filter type="subtree">
         <top xmlns="http://example.com/schema/1.2/config">
             <users/> -> selection node
         </top>
     </filter>
     ```

     이 예에서 "top" 요소는 containment 노드, "users" 요소는 선택 노드이다. 구성 데이터스토어의 루트인 "top" 요소 내에서 발생하는 "http://example.com/schema/1.2/config" 네임스페이스의 "users" 노드만 필터 출력에 포함된다.

  5. Content Match Nodes
     **단순한 콘텐츠를 포함하는 leaf node를 "content match node"라고 한다.** 필터 출력을 위해 형제 노드 일부 또는 전체를 선택하는 데 사용되며, 리프 노드 요소 컨텐츠의 정확한 일치 필터를 나타낸다. 컨텐츠 일치 노드에 적용되는 제한 사항은 다음과 같다.

     - Content Match Nodes에는 중첩된 요소가 포함되어서는 안 된다.

     - 여러 Content Match Nodes(즉, 형제 노드)는 "AND" 표현식으로 논리적으로 결합된다.

     - mixed content 필터링은 지원되지 않는다.

     - list content 필터링은 지원되지 않음.

     - whitespace-only content 필터링은 지원되지 않는다.

     - **Content Match Nodes에는 공백이 아닌 문자가 포함되어야 한다. 빈 요소(예: "foo""/foo")는 선택 노드(예: "foo/")로 해석**된다.

     - 선행 및 후행 공백 문자는 무시되지만, 텍스트 문자 블록 내의 공백 문자는 무시되거나 수정되지 않는다.
     - 하위 트리 필터 식의 지정된 모든 형제 컨텐츠 일치 노드가 "참"이면 다음과 같은 방법으로 필터 출력 노드가 선택된다.
     - 형제 집합의 각 콘텐츠 일치 노드가 필터 출력에 포함된다.
     - 형제 집합에 containment node가 있는 경우 이들을 추가로 처리하고 중첩된 필터 기준도 충족하면 포함시킨다.
     - 형제 집합에 선택 노드가 있으면 이들 노드가 모두 필터 출력에 포함된다.
     - 선택 노드의 형제 노드가 개념 데이터 구조(예: 목록 키 리프)의 인스턴스 식별자 구성요소인 경우, 이들 노드는 필터 출력에도 포함될 수 있다.
     - 그렇지 않으면(즉, 필터 형제 집합에 선택 또는 격납 노드 없음), 기본 데이터 모델에서 이 수준에서 정의된 모든 노드(및 하위 트리(있는 경우)는 필터 출력에 반환된다.

     ```xml
     <filter type="subtree">
         <top xmlns="http://example.com/schema/1.2/config">
             <users> -> containment node
                 <user> -> containment node
                     <name>fred</name> -> content match node
                 </user>
             </users>
         </top>
     </filter>
     ```

     이 예에서 "users" 와 "user" 노드는 둘 다 containment node이며, "name" 은 content match node이다. "name"의 형제 노드가 지정되어 있지 않기 때문에 (따라서 containment 또는 selection 노드가 없으므로) "name"의 형제 노드는 모두 필터 출력에서 반환된다. **element 계층 구조가 일치하고 "name" 요소가 "fred"와 동일한 "http://example.com/schema/1.2/config" 네임스페이스의 "user" 노드만 필터 출력에 포함**된다.

     

- Subtree Filtering Examples

  ```xml
  <!-- 1. No Filter -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <get/> -> get operation 비어있을 경우 전체 데이터 모델 반환
  </rpc>
  
  <rpc-reply message-id="101"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <data>
          <!-- ... entire set of data returned ... -->
      </data>
  </rpc-reply>
  
  <!-- 2. Empty Filter -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <get>
          <filter type="subtree"> -> 비어있다고 error X, content match 또는 selection node 미정
          </filter>
      </get>
  </rpc>
  
  <rpc-reply message-id="101"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <data>
      </data>
  </rpc-reply>
  
  <!-- 3. Select the Entire <users> Subtree -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <get-config>
          <source>
              <running/>
          </source>
          <filter type="subtree">
              <top xmlns="http://example.com/schema/1.2/config">
                  <users/> -> selection node, subtree는 filter 의해 선택됨
              </top>
          </filter>
      </get-config>
  </rpc>
  
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <get-config>
          <source>
              <running/>
          </source>
          <filter type="subtree">
              <top xmlns="http://example.com/schema/1.2/config">
                  <users>
                      <user/> -> "users"는 하나의 element "user" 만 정의하기 때문에
                  </users>
              </top>
          </filter>
      </get-config>
  </rpc>
  위에 두개 rpc 표현식 같은 의미
  
  <!-- 4. Select All <name> Elements within the <users> Subtree -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users> -> one containment
            <user> -> two containment
              <name/> -> one selection
                (동일한 형제 집합에 있는 "name" element 모든 인스턴스 필터 출력에서 선택됨)
            </user>
          </users>
        </top>
      </filter>
    </get-config>
  </rpc>
  
  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>root</name>
          </user>
          <user>
            <name>fred</name>
          </user>
          <user>
            <name>barney</name>
          </user>
        </users>
      </top>
    </data>
  </rpc-reply>
  
  <!-- 5. One Specific <user> Entry -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users> -> one containment
            <user> -> two containment
              <name>fred</name> -> one content match
            </user>
          </users>
        </top>
      </filter>
    </get-config>
  </rpc>
  
  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>fred</name>
            <type>admin</type>
            <full-name>Fred Flintstone</full-name>
            <company-info>
              <dept>2</dept>
              <id>2</id>
            </company-info>
          </user>
        </users>
      </top>
    </data>
  </rpc-reply>
  
  <!-- 6. Specific Elements from a Specific <user> Entry -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users> -> one containment
            <user> -> two containment
              <name>fred</name> -> one content match
              <type/> -> one selection
              <full-name/> -> two selection
                "name"이 fred이고, "type"과 "full-name" elements 출력
            </user>
          </users>
        </top>
      </filter>
    </get-config>
  </rpc>
  
  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>fred</name>
            <type>admin</type>
            <full-name>Fred Flintstone</full-name>
          </user>
        </users>
      </top>
    </data>
  </rpc-reply>
  
  <!-- 7. Multiple Subtree -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get-config>
      <source>
        <running/>
      </source>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/config">
          <users> 
            <user> 
              <name>root</name>
              <company-info/>
            </user>
  - 1. root subtree : 2 containment("users","user"), 1 content match("name"), 1 selection("company-info") 
            <user>
              <name>fred</name> 
              <company-info>
                <id/> 
              </company-info>
            </user>
  - 2. fred subtree : 3 containment("users","user","company-info"), 1 content match("name"), 1 selection("id") 
            <user>
              <name>barney</name> 
              <type>superuser</type>
              <company-info>
                <dept/>
              </company-info>
            </user>
  - 3. barney : 3 containment("users","user","company-info"), 2 content match("name","type"), 1 selection("dept")
          </users>
        </top>
      </filter>
    </get-config>
  </rpc>
  
  <rpc-reply message-id="101"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <top xmlns="http://example.com/schema/1.2/config">
        <users>
          <user>
            <name>root</name>
            <company-info>
              <dept>1</dept>
              <id>1</id>
            </company-info>
          </user>
          <user>
            <name>fred</name>
            <company-info>
              <id>2</id>
            </company-info>
          </user>
        </users>
      </top>
    </data>
  </rpc-reply>
  
  <!-- 8. Elements with Attribute Naming -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get>
      <filter type="subtree">
        <t:top xmlns:t="http://example.com/schema/1.2/stats">
          <t:interfaces> -> one containment
            <t:interface t:ifName="eth0"/>
          </t:interfaces>
        </t:top>
      </filter>
    </get>
  </rpc>
  
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <get>
      <filter type="subtree">
        <top xmlns="http://example.com/schema/1.2/stats">
          <interfaces>
            <interface>
              <ifName>eth0</ifName>
            </interface>
          </interfaces>
        </top>
      </filter>
    </get>
  </rpc>
  위의 두개 rpc 표현식 같은 의미
  
  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <data>
      <t:top xmlns:t="http://example.com/schema/1.2/stats">
        <t:interfaces>
          <t:interface t:ifName="eth0">
            <t:ifInOctets>45621</t:ifInOctets>
            <t:ifOutOctets>774344</t:ifOutOctets>
          </t:interface>
        </t:interfaces>
      </t:top>
    </data>
  </rpc-reply>
  ```

  
### 1.2.8 Protocol Operations

  NETCONF 프로토콜은 기기 구성을 관리하고 기기 상태 정보를 검색하기 위한 소규모 하위 작업 세트를 제공한다. 기본 프로토콜은 구성 데이터스토어를 검색, 구성, 복사 및 삭제하는 작업을 제공한다. 기기가 광고하는 기능에 따라 추가 작업이 제공된다.

**1.2.8.1 "get"**

- Description : **실행중인 구성 및 장치 상태 정보**를 검색

- Parameter

  1. Filter : 이 매개변수는 검색할 시스템 구성 및 상태 데이터의 일부를 지정함.

     "filter" element는 선택적으로 "type" 속성을 포함 할 수 있다. 이 속성은 "filter" element 내에서 사용되는 필터링 구문 유형을 나타낸다.

- Positive Response : 장치가 요청을 충족할 수 있는 경우 "rpc-reply"가 전송된다. "data" 섹션에는 적절한 하위 집합이 포함되어 있다.

- Negative Response : 어떤 이유로든 요청을 완료할 수 없는경우 "rpc-error" 요소가 "rpc-reply"에 포함된다.

**1.2.8.2 "get-config"**

  - Description : **지정된 config datastore의 전체 또는 일부**를 검색

  - Parameter

    1. Source : 쿼리 중인 config datastore의 이름 (ex: "running/")

    2. Filter : 이 매개변수는 검색할 디바이스 구성 데이터스토어의 일부를 식별한다. 매개 변수가 없으면 전체 구성이 반환된다.

       "filter" element는 선택적으로 "type" 속성을 포함하고 있다. 이 속성은 "filter" element 내에서 사용되는 필터링 구문의 유형을 나타낸다. NETCONF의 기본 필더링 메커니즘은 **"Subtree Filtering"**이라고 한다.

  - Positive Response : 기기가 요청을 만족시킬 수 있는 경우, 서버는 질의 결과와 함께 "data" element가 포함된 "rpc replay" element를 전송한다.

  - Negative Response : 어떠한 이유로도 요청을 완료할 수 없는 경우에는 "rpc-error" element가 "rpc-response"에 포함되어 있다.

 **1.2.8.3 "edit-config"**

  - Description : "edit-config" 작업은 지정된 구성의 전부 또는 일부를 지정된 대상 구성 데이터 스토어에 로드한다. 이 작업을 통해 로컬 파일, 원격 파일 또는 인라인과 같은 여러 가지 방법으로 새 구성을 표시할 수 있다. 대상 구성 데이터스토어가 없으면 생성된다.

    NETCONF peer가 :url 기능을 지원하는 경우, "config" parameter 대신 "url" element 가 나타날 수 있다.

    장치는 소스와 대상 구성을 분석하고 요청된 변경을 수행한다. 대상 구성이 "copy-config" 메시지와 같이 반드시 교체되는 것은 아니다. 대신 소스의 데이터와 요청된 작업에 따라 대상 구성이 변경된다.

    "edit-config" 연산에 기본 데이터 모델의 동일한 개념 노드에 적용되는 여러 하위 연산이 포함된 경우, 연산의 결과는 정의되지 않은 것이다.(즉, NETCONF protocol 범위 밖)

    1. Source : "config" 하위 트리의 요소에는 NETCONF 네임스페이스에 속하는 "operation" 특성이 포함될 수 있다. 속성은 연산을 수행하기 위한 구성의 지점을 식별하고, "config" 하위 트리의 여러 요소에 나타날 수 있다.

       "operation" 속성을 지정하지 않으면 구성이 구성 데이터스토어에 병합된다. "operation"속성은 다음 값 중 하나를 가진다.

       * **merge** : 이 속성을 포함하는 요소에 의해 식별된 구성 데이터는 "target" parameter로 식별된 구성 데이터스토어의 해당 레밸의 구성과 병합된다. 이것이 기본 동작이다.
       * **replace** : 이 속성을 포함하는 요소에 의해 식별된 구성 데이터는 "target" 매개변수로 식별된 구성 데이터스토어의 관련 구성을 대체한다. 구성 데이터스토어에 이러한 구성 데이터가 없으면 생성된다. 전체 대상 구성을 대체하는 "copy-config" 작업과 달리, "config" parameter에 실제로 존재하는 구성만이 영향을 받는다.
       * **make** : 이 속성을 포함하는 요소에서 식별된 구성 데이터는 구성 데이터스토어에 구성데이터가 없는 경우에만 구성에 추가된다. 구성 데이터가 존재하는 경우 "data-exist"의 "error-tag" 값으로 "rpc-error" 요소가 반환된다.
       * **delete** : 이 속성을 포함하는 요소로 식별된 구성데이터는 구성 데이터스토어에 현재 구성 데이터가 존재하는 경우에만 구성에서 삭제된다. 구성 데이터가 존재하지 않는 경우 , "rpc-error" element는 "data-missing"의 "error-tag"값과 함께 반환된다.
       * **remove** : 이 속성을 포함하는 요소로 식별된 구성 데이터는 구성 데이터스토어에 현재 구성 데이터가 있는 경우 구성에서 삭제된다. 구성 데이터가 없는 경우, "remove"작업은 서버에서 자동으로 무시된다.

  - Parameter

    1. target : 편집 중인 구성데이터스토어의 이름(ex: "running/" 또는 "candidate/")
    2. default-operation : 이 "edit-config" 요청에 대한 기본 연산 ("operation" 속성에 설명됨)을 선택한다. "default-operation" parameter의 기본값은 "merge"이다. "default-operation" parameter는 선택사항이지만. 제공될 경우 다음 값 중 하나를 가진다.
       - **merge** : "config" 매개 변수의 구성 데이터가 대상 데이터스토어의 해당 수준에 있는 구성과 병합된다. 이것이 기본 동작이다.
       - **replace** : "config" 매개 변수의 구성 데이터가 대상 데이터스토어의 구성을 완전히 대체한다. 이전에 저장한 구성 데이터를 로드하는 데 유용하다.
    3. none : 수신 구성 데이터가 "operation" 속성을 사용하여 다른 작업을 요청하지 않는 한, 그리고 수신 구성 데아터가 "operation" 속성을 사용할 때까지 대상 데이터스토어는 "config" 매개 변수의 구성에 영향을 받지 않는다. "config" 매개변수의 구성에 대상 데이터스토어에 해당 수준이 없는데이터가 포함된 경우, 데이터 누락의 "error-tag" 값과 함께 "rpc-error"가 반환된다, "none"을 사용하면 "remove"와 같은 작업을 통해 의도치 않게 삭제할 요소의 상위 계층이 생성되는 것을 방지할 수 있다.

  - Positive Response : 기기가 요청을 만족시킬 수  있었다면, "ok" element를 담은 "rpc-reply"가 전송된다.

  - Negative Response : 어떠한 이유로도 요청을 완료할 수 없는 경우 "rpc-error" 응답이 전송된다.

**1.2.8.4 "copy-config"**

  - Description : 전체 구성 데이터스토어를 다른 전체 구성 데이터스토어의 내용으로 생성하거나 교체. 대상 데이터스토어가 있으면 덮어쓰게 된다. 그렇지 않으면 새 것이 생성된다. NETCONF peer가 :url 기능을 지원하는 경우, "url" element는 "source" 또는 "target" parameter로 나타날 수 있다.

    쓰기 가능 실행 기능을 사용하더라도, 디바이스는 "copy-config" 작업의 "target" 매개변수로 "running/" 구성 데이터스토어를 지원하지 않도록 선택할 수 있다. 기기는 "source"와 "target" 매개변수가 모두 "url" element를 사용하는 원격에서 원격으로 복사 작업을 지원하지 않도록 선택할 수 있다. "source"와 "target" parameter가 동일한 URL 또는 구성 데이터스토어를 식별하는 경우, 반드시 "유효하지 않은 값"을 포함하는 error-tag와 함께 오류를 반환해야 한다.

  - Parameter

    1. target : "copy-config" 작업의 대상으로 사용할 구성 데이터스토어의 이름
    2. source : "copy-config" 작업의 소스로 사용할 구성 데이터스토어의 이름 또는 복사할 전체 구성을 포함하는 "config" element의 이름

  - Positive Response : 기기가 요청을 만족시킬 수 있었다면, "ok" element를 포함하는 "rpc-reply"가 전송된다.

  - Negative Response : 어떠한 이유로도 요청을 완료할 수 없는 경우에는 "rpc-error" 요소가 "rpc-response" 안에 포함된다.

**1.2.8.5 "delete-config"**

  - Description : 구성 데이터스토어를 삭제. "running" 구성 데이터스토어는 삭제할 수  없다. NETCONF peer가 :url 기능을 지원하는 경우, "url" element는 "target" parameter로 나타날 수 있다.
  - Parameter : 삭제할 구성데이터스토어의 이름
  - Positive Response : 기기가 요청을 만족시킬 수 있었다면, "ok" element를 포함하는 "rpc-reply"가 전송된다.
  - Negative Response : 어떠한 이유로도 요청을 완료할 수 없는 경우에는 "rpc-error" 요소가 "rpc-response" 안에 포함된다. 

**1.2.8.6 "lock"**

- Description : "lock"작업을 통해 클라이언트는 장치의 전체 구성 데이터 저장소 시스템을 잠글 수 있다. 잠금을 획득하면 **서버는 이 세션에서 요청한 것 이외의 잠긴 리소스에 대한 변경을 방지**해야 한다. 리소스를 수정하기 위한 SNMP, CLI 요청은 적절한 오류와 함께 실패해야 한다. **"lock" 작업은 필수 매개변수인 "target"을 사용**한다. "target" 매개변수는 **잠글 구성 데이터 저장소의 이름을 지정(잠금 활성화 된 구성 데이터 저장소에서는 "edit-config", "copy-config" 불가)**. "kill-session" 작업을 통해 다른 NETCONF 세션이 소유한 잠금을 강제로 해제할 수 있다.

- Parameters

  1. target : lock을 위한 구성 데이터스토어의 이름

- Positive Response : 장치가 요청을 충족할 수 있는 경우 "ok" 요소를 포함하는 "rpc-reply"가 전송

- Negative Response : 어떤 이유로든 요청을 완료할 수 없는 경우 "rpc-error" 요소가 "rpc-reply"에 포함됨

  **잠금이 이미 유지된 경우 "error-tag" 요소는 "lock-denied"가 되고 "error-info" 요소에는 잠금 소유자의 "session-id"가 포함됨. 비NETCONF entity(SNMP, CLI ...)가 잠금을 보유한 경우 "session-id"는 0.**

  ```xml
  <!-- 1. 잠금 성공을 취득한 경우 -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <lock>
          <target>
              <running/>
          </target>
      </lock>
  </rpc>
  
  <rpc-reply message-id="101"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
      <ok/> <!-- lock succeeded -->
  </rpc-reply>
  
  <!-- 2. 잠금 실패를 취득한 경우 -->
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <lock>
      <target>
        <running/>
      </target>
    </lock>
  </rpc>
  
  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <rpc-error> <!-- lock failed -->
      <error-type>protocol</error-type>
      <error-tag>lock-denied</error-tag>
      <error-severity>error</error-severity>
      <error-message>
        Lock failed, lock is already held
      </error-message>
      <error-info>
        <session-id>454</session-id>
        <!-- lock is held by NETCONF session 454 -->
      </error-info>
    </rpc-error>
  </rpc-reply>
  ```



**1.2.8.7 "unlock"**

- Description : "unlock"작업은 이전에 "lock" 작업으로 얻은 구성 잠금을 해제하는데 사용된다.

  1. 지정된 잠금이 현재 활성화 되어 있지 않은 경우
  2. "unlock" 세션과 "lock" 세션이 다를 경우

  위 조건 중 하나에 해당하면 "unlock" 작업 성공 불가

- Parameter

  1. target : unlock을 위한 구성 데이터스토어의 이름

- Positive Response : 장치가 요청을 충족할 수 있는 경우 "ok" 요소를 포함하는 "rpc-reply"가 전송

- Negative Response : 어떤 이유로든 요청을 완료할 수 없는 경우 "rpc-error" 요소가 "rpc-reply"에 포함됨 

  ```xml
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <unlock>
      <target>
       <running/>
      </target>
    </unlock>
  </rpc>
  
  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
  ```



**1.2.8.8  "close-session"**

- Description : NETCONF 세션의 정상 종료를 요청

  서버는 세션과 관련된 모든 잠금 및 리소스를 해제 모든 관련 연결을 정상적으로 종료.

- Positive Response : 장치가 요청을 충족할 수 있는 경우 "ok" 요소를 포함하는 "rpc-reply"가 전송

- Negative Response : 어떤 이유로든 요청을 완료할 수 없는 경우 "rpc-error" 요소가 "rpc-reply"에 포함됨

  ```XML
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <close-session/>
  </rpc>
  
  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
  ```

**1.2.8.9 "kill-session"**

- Description : NETCONF 강제 종료

  NETCONF entity가 열린 세션에 대한 :kill-session"요청을 받으면 현재 처리중인 모든 작업을 중단하고 세션과 관련된 모든 잠금 및 리소스를 해제하며 연결된 모든 연결을 닫는다.

- Parameter

  1. session-id : 종료 할 NETCONF 세션의 세션 식별자. 이 값이 현재 세션 ID와 같으면 "잘못된 값"오류가 반환

- Positive Response : 장치가 요청을 충족할 수 있는 경우 "ok" 요소를 포함하는 "rpc-reply"가 전송

- Negative Response : 어떤 이유로든 요청을 완료할 수 없는 경우 "rpc-error" 요소가 "rpc-reply"에 포함됨

  ```xml
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <kill-session>
      <session-id>4</session-id>
    </kill-session>
  </rpc>
  
  <rpc-reply message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <ok/>
  </rpc-reply>
  ```

### 1.2.9 Capabilities

Capabilities(기능)은 세션을 설정하는 동안 각 peer가 보낸 메시지에 알려진다. NETCONF 세션이 열려졌을때, 각 peer(server, client)는 반드시 해당 peer의 기능 목록을 포함하는 "hello" 메시지를 보내야한다.

- 전송해야 하는 최소한의 항목
  1. 각 peer는 기본 NETCONF 기능인 "urn:ietf:params:netconf:base:1.1"을 전송해야 한다.
  2. peer는 여러 프로토콜 버전을 지원함을 나타내기위해 이전 NETCONF 버전에 대한 기능을 포함할 수 있다.

두 NETCONF peer 모두 다른 피어가 공통 프로토콜 버전을 광고했는지 확인해야 한다. 프로토콜 버전 기능 URI를 비교할 때 기본 부분만 사용되며, 매개변수가 URI 문자열 끝에 인코딩되는 경우, 공통 프로토콜 버전 기능을 찾을 수 없는 경우, NETCONF peer는 세션을 계속하지 않아야 한다. 둘 이상의 공통 프로토콜 버전 URI가 있는 경우 두 피어에서 가장 높은 번호의 프로토콜 버전을 사용해야 한다.

**"hello" element를 보내는 서버는 NETCONF 세션의  session id를 포함하는 "session-id" element를 반드시 포함**해야한다. **"hello"  element를 보내는 클라이언트는 "session-id" element를 포함하지 않아도 된다.**
**"session-id" element가 있는 "hello" 메시지를 수신하는 서버는 NETCONF 세션을 종료.**
**서버의 "hello" 메시지에서 "session-id" element를 수신하지 않는 클라이언트는 반드시 NETCONF 세션을 종료.**

```XML
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
  <capabilities>
    <capability>
      urn:ietf:params:netconf:base:1.1 -> 기본 NETCONF 기능
    </capability>
    <capability>
      urn:ietf:params:netconf:capability:startup:1.0 -> NETCONF 문서에 정의된 NETCONF 기능
    </capability>
    <capability>
      http://example.net/router/2.3/myfeature -> 구현 별 기능
    </capability>
  </capabilities>
  <session-id>4</session-id>
</hello>
```

- Capability 종류

  1. Writable-Running Capability
     urn:ietf:params:netconf:capability:**writable-running**:1.0

  2. Candidate Configuration Capability
     urn:ietf:params:netconf:capability:**candidate**:1.0

  3. Confirmed Commit Capability
     urn:ietf:params:netconf:capability:**confirmed-commit**:1.1

  4. Rollback-on-Error Capability
     urn:ietf:params:netconf:capability:**rollback-on-error**:1.0

  5. Validate Capability
     urn:ietf:params:netconf:capability:**validate**:1.1

  6. Distinct Startup Capability
     urn:ietf:params:netconf:capability:**startup**:1.0

  7. URL Capability
     urn:ietf:params:netconf:capability:url:1.0?scheme={name,...}


     urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file

##  1.3 RFC 6020:YNAG-A Data Modeling Language for the Network Configuration Protocol(NETCONF)

YANG은 네트워크 구성(NETCONF), NETCONF 원격 프로시저 호출 및 NETCONF 알림에 의해 조작되는 구성 및 상태 데이터를 모델링 하는데 사용되는 데이터 모델링 언어.

이 문서는 YANG 언어의 구문과 의미론, YANG 모듈에 정의된 데이터 모델이 XML(Extensible Markup Language)에서 어떻게 표현되는지, NETCONF 연산을 사용하여 데이터를 조작하는 방법에 대해 설명한다.

### 1.3.1 Language Overview

**1.3.1.1 Modules and Submodules**

- **Module**은

1. **YANG의 기본 정의 단위**. 
2. **단일 데이터 모델을 정의**. 
3. **완전하고 일관된 모델을 정의하거나 추가 노드로 기존 데이터 모델을 보강** 할 수 있음.

- **Submodule**은 

1. **module의 정의를 제공하는 부분 module**. 

2. module은 여러 submodule을 포함할 수 있지만 **각 submodule은 하나의 module에만 속함**.

   **모든 표준 module 및 submodule의 이름은 고유.**

- Import and Include by Revision

  "import" statement : 모듈 또는 하위 모듈이 다른 모듈에 정의된 정의를 참조할 수 있음.

  "include" statement : 모듈에 속한 각 하위 모듈을 식별하는데 사용.

  ```c
  module a {
      revision 2008-01-01 { ... }
      grouping a {
          leaf eh { .... }
      }
  }
  
  module b {
      import a {
          prefix p;
          revision-date 2008-01-01;
      }
  
      container bee {
          uses p:a;
      }
  }
  ```

- Module Hierarchies

  YANG은 데이터가 하나 이상의 최상위 노드를 가질 수 있는 다중 계층 구조를 허용함.

  ```c
  module my-config {
      namespace "http://example.com/schema/config";
      prefix "co";
  
      container system { ... }
      container routing { ... }
  }
  ```

  NETCONF에서 다음과 같이 encoding 될 수 있다.

  ```xml
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="http://example.com/schema/config">
          <!-- system data here -->
        </system>
        <routing xmlns="http://example.com/schema/config">
          <!-- routing data here -->
        </routing>
      </config>
    </edit-config>
  </rpc>
  ```

**1.3.1.2 data Modeling Basics**

YANG은 데이터 모델링을 위해 4가지 주요 유형의 데이터 노드를 정의한다.

- **Leaf Nodes**

  Leaf Node에는 **정수 또는 문자열과 같은 간단한 데이터**가 포함됨.

  ```xml
  YANG Example:
    leaf host-name {
      type string;
      description
        "Hostname for this system.";
    }
  
  XML Encoding Example:
    <host-name>my.example.com</host-name>
  ```

- **Leaf-List Nodes**

  leaf-list는 특정 유형 값의 시퀀스를 정의함.

  ```xml
  YANG Example:
    leaf-list domain-search {
      type string;
      description
        "List of domain names to search.";
    }
  
  XML Encoding Example:
    <domain-search>high.example.com</domain-search>
    <domain-search>low.example.com</domain-search>
    <domain-search>everywhere.example.com</domain-search>
  ```

- **Container Nodes**

  Container는 subtree에서 관련 노드를 그룹화하는데 사용됨. 
  Container에는 자식노드만 있고 값은 없음. 
  Container에는 모든 유형의 자식노드가 포함될 수 있음.

  ```xml
  YANG Example:
    container system {
      container login {
        leaf message {
          type string;
          description
            "Message given at start of login session.";
        }
      }
    }
  
  XML Encoding Example:
    <system>
      <login>
        <message>Good morning</message>
      </login>
    </syste
  ```

- **List Nodes**

  List는 목록 항목의 순서를 정의함.
  각 항목은 Container와 같으며 정의된 key leaf가 있는 경우 해당 key leaf 값으로 고유하게 식별됨.
  list는 여러 key leaf를 정의할 수 있으며, 모든 유형의 자식 노드를 원하는 만큼 포함할 수 있음.

  ```xml
  YANG Example:
    list user {
      key "name";
      leaf name {
        type string;
      }
      leaf full-name {
        type string;
      }
      leaf class {
        type string;
      }
    }
  
  XML Encoding Example:
    <user>
      <name>glocks</name>
      <full-name>Goldie Locks</full-name>
      <class>intruder</class>
    </user>
    <user>
      <name>snowey</name>
      <full-name>Snow White</full-name>
      <class>free-loader</class>
    </user>
    <user>
      <name>rzell</name>
      <full-name>Rapun Zell</full-name>
      <class>tower</class>
    </user>
  ```

**1.3.1.3 Configuration and State Data**

YANG은 "config"문을 기반으로 state data와 configuration data를 모델링 할 수 있음.
노드에 **"config false"** 태그가 지정되면 하위 계층 구조가 **state date**로 플래그 지정됨.
노드에 **"config true"** 태그가 지정되면 하위 계층 구조가 **configuration data**로 플래그 지정됨.

```c
list interface {
  key "name";
  config true;

  leaf name {
    type string;
  }
  leaf speed {
    type enumeration {
      enum 10m;
      enum 100m;
      enum auto;
    }
  }
  leaf observed-speed {
    type uint32;
    config false;
  }
}
```

**1.3.1.4 Reusable Node Groups (grouping)**

노드 그룹은 "grouping"문을 사용하여 재사용 가능한 컬렉션으로 조합할 수 있다. 
그룹화는 "uses"문으로 인스턴스화 되는 노드 집합을 정의한다.

```xml
YANG Example:
  grouping target {
    leaf address {
      type inet:ip-address;
      description "Target IP address.";
    }
    leaf port {
      type inet:port-number;
       description "Target port number.";
    }
  }
  container peer {
    container destination {
      uses target;
    }
  }

XML Encoding Example:
  <peer>
    <destination>
      <address>2001:db8::2</address>
      <port>830</port>
    </destination>
  </peer>

그룹화는 사용되는 대로 세분화하여 특정 명령문을 대체할 수 있다.
container connection {
  container source {
    uses target {
      refine "address" {
        description "Source IP address.";
      }
      refine "port" {
        description "Source port number.";
      }
    }
  }
  container destination {
    uses target {
      refine "address" {
        description "Destination IP address.";
      }
      refine "port" {
        description "Destination port number.";
      }
    }
  }
}
```

**1.3.1.5 Choices**

case문과 유사.
"choice" 및 "case" 문을 사용하여 호환되지 않는 노드를 별개의 선택항목으로 분리 가능.
"choice"문에는 함께 나타날 수  없는 스키마 노드 집합을 정의하는 "case"문 집합이 포함되어 있음.

```xml
YANG Example:
  container food {
    choice snack {
      case sports-arena {
        leaf pretzel {
          type empty;
        }
          leaf beer {
          type empty;
        }
      }
      case late-night {
        leaf chocolate {
          type enumeration {
            enum dark;
            enum milk;
            enum first-available;
          }
        }
      }
    }
  }

XML Encoding Example:
  <food>
    <pretzel/>
    <beer/>
  </food>
```

**1.3.1.6 Extending Data Models (augment)**

if-else 문과 유사
모듈이 현재 모듈(및 하위 모듈)및 외부 모듈을 포함하여 데이터 모델에 추가 노드를 삽입할 수 있다.
"augment"문은 데이터 모델 계층에서 새 노드가 삽입될때의 위치를 정의하고 "when"문은 새 노드가 유효한 경우 조건을 정의함.

```
class가 "wheel"이 아닌 경우에만 유효한 "uid" 노드를 정의

YANG Example:
augment /system/login/user {
  when "class != 'wheel'";
  leaf uid {
    type uint16 {
      range "1000 .. 30000";
    }
  }
}

XML Encoding Example:
 <user>
   <name>alicew</name>
   <full-name>Alice N. Wonderland</full-name>
   <class>drop-out</class>
   <other:uid>1024</other:uid>
 </user>
```

**1.3.1.7 Operation Definitions**

Operation의 이름, 입력 매개변수, 출력 매개변수는 YANG 데이터 정의 명령문을 사용하여 모델링 됨.
Operation은 Container, list data node에 연결될 수도 있다. 이러한 작업은 "action"문으로 정의.

```xml
YANG Example for an operation at the top level:
  rpc activate-software-image {
    input {
      leaf image-name {
        type string;
      }
    }
    output {
      leaf status {
        type string;
      }
    }
  }

NETCONF XML Example:
  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <activate-software-image xmlns="http://example.com/system">
      <image-name>example-fw-2.3</image-name>
    </activate-software-image>
  </rpc>
  <rpc-reply message-id="101"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <status xmlns="http://example.com/system">
      The image example-fw-2.3 is being installed.
    </status>
  </rpc-reply>

YANG Example for an operation tied to a list data node:
  list interface {
    key "name";

    leaf name {
      type string;
    }
    action ping {
      input {
        leaf destination {
          type inet:ip-address;
        }
      }
      output {
        leaf packet-loss {
          type uint8;
        }
      }
    }
  }

NETCONF XML Example:
  <rpc message-id="102"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <action xmlns="urn:ietf:params:xml:ns:yang:1">
      <interface xmlns="http://example.com/system">
        <name>eth1</name>
        <ping>
          <destination>192.0.2.1</destination>
        </ping>
      </interface>
    </action>
  </rpc>

  <rpc-reply message-id="102"
             xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
             xmlns:sys="http://example.com/system">
    <sys:packet-loss>60</sys:packet-loss>
  </rpc-reply>

```

**1.3.1.8 Notification Definitions**

YANG은 notification의 정의를 허용함.

```xml
YANG Example:
  notification link-failure {
    description
      "A link failure has been detected.";
    leaf if-name {
      type leafref {
        path "/interface/name";
      }
    }
    leaf if-admin-status {
      type admin-status;
    }
    leaf if-oper-status {
      type oper-status;
    }
  }

NETCONF XML Example:
  <notification
      xmlns="urn:ietf:params:netconf:capability:notification:1.0">
    <eventTime>2007-09-01T10:00:00Z</eventTime>
    <link-failure xmlns="urn:example:system">
      <if-name>so-1/2/3.0</if-name>
      <if-admin-status>up</if-admin-status>
      <if-oper-status>down</if-oper-status>
    </link-failure>
  </notification>
```



### 1.3.2 Language Concepts

**1.3.2.1 File Layout**
YANG module 및 submodule은 일반적으로 파일 당 하나의 module 또는 submodule에 저장된다. 파일의 형식(".yang", ".yin")

**1.3.2.2 XML Namespaces**
모든 YANG 정의는 고유한 URI인 특정 XML 네임스페이스에 바인딩 된 모듈내에 지정된다.
NETCONF 클라이언트 또는 서버는 데이터의 XML 인코딩 중에 네임스페이스를 사용함.
YANG은 NETCONF "edit-config" 작업 및 "error-info" 에 대한 XML 네임스페이스를 정의함. 

```
"urn:ietf:params:xml:ns:yang:1"
```

**1.3.2.3 Conformance**

- Announcing Conformance Information in the "hello" Message
  네임스페이스 URI는 NETCONF 서버에 의한 YANG 모듈 지원을 나타내기 위해 NETCONF "hello" 메시지의 기능으로 알려야 함. URI는 반드시 다음의 form을 따름

  ```
  capability-string   = namespace-uri [ parameter-list ] 
  "namespace-uri"-> "namespace"문에 나타나는 모듈의 네임스페이스 URI
  parameter-list      = "?" parameter *( "&" parameter )
  parameter           = revision-parameter /
                        module-parameter /
                        feature-parameter /
                        deviation-parameter
  revision-parameter  = "revision=" revision-date 
  "revision-date"-> NETCONF 서버가 구현하는 모듈의 개정판
  module-parameter    = "module=" module-name 
  "module-name" -> "module"문에 나타나는 모듈의 이름
  feature-parameter   = "features=" feature *( "," feature )
  "feature" -> 장치에 의해 구현된 선택적 기능의 이름
  deviation-parameter = "deviations=" deviation *( "," deviation )
  "deviations" -> 장치 편차를 정의하는 모듈의 이름
  ```

-  Modules

  서버는 "hello" 메시지를 통해 지원되는 모듈의 이름을 나타낸다. module name space는 기능 문자열에서 기본 URI로 인코딩되고 module 이름은 기본 URI에 대한 "module" 매개변수로 인코딩 된다.

  ```xml
  <!-- 이 <hello> 메시지는 "syslog"라는 하나의 module을 알린다. -->
  <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <capability>
      http://example.com/syslog?module=syslog&amp;revision=2008-04-01
    </capability>
  </hello>
  ```

- Features

  서버는 "hello" 메시지를 통해 지원되는 기능의 이름을 나타낸다. "hello" 메시지에서 기능은 URI내의 "features" 매개변수로 인코딩된다. 이 매개변수의 값은 장치가 특정 모듈에 대해 지원하는 기능 이름의 쉼표로 구분된 목록.

  ```xml
  <!-- 이 <hello> 메시지는 "syslog"라는 module의 "local-strage"기능을 지원함을 클라이언트에게 알린다. -->
  <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <capability>
      http://example.com/syslog?module=syslog&amp;features=local-storage
    </capability>
  </hello>
  ```

- Deviations(편차)

  장치 편차는 "deviations"매개 변수를 통해 정해진다. "deviations" 매개 변수의 값은 기능 모듈의 편차를 포함하는 쉼표로 구분된 모듈 목록.

  ```xml
  <!-- 이 <hello> 메시지는 모듈 "my-devs"에 나열된 deviations에 따라 모듈 "syslog"에서 벗어남을 클라이언트에 알리는 두개의 모듈을 광고한다. -->
  <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <capability>
      http://example.com/syslog?module=syslog&amp;deviations=my-devs
    </capability>
    <capability>
      http://example.com/my-deviations?module=my-devs
    </capability>
  </hello>
  ```



### 1.3.3 YANG Statements

**1.3.3.1 The "module" Statement**

"module"문은 모듈의 이름을 정의하고 모듈에 속하 모든 문을 함께 그룹화 한다.
"module"문의 인수는 모듈의 이름이며 그 뒤에 자세한 모듈 정보를 포함하는 하위 문 블록이 온다.
"module" name은 식별자(Identifier)이다.

```c
module <module-name> {

  // header information
  <yang-version statement>
  <namespace statement>
  <prefix statement>

  // linkage statements
  <import statements>
  <include statements>

  // meta-information
  <organization statement>
  <contact statement>
  <description statement>
  <reference statement>

  // revision history
  <revision statements>

  // module definitions
  <other statements>
}
```

- The "yang-version" Statement

  "yang-version"문은 모듈 개발에 사용된 YANG 언어 버전을 지정.
  "yang-version"문 포함하지 않거나 "1" 값을 포함하는 모듈 또는 하위 모듈은 YANG  버전 1용으로 개발되었음.
  "1.1"이외의 버전에 대한 "yang-version"문 처리는 이 사양의 범위를 벗어남.

- The "namespace" Statement

  "namespace"문은 그룹 내에 정의된 data node, action node 및 notification node에 대한 식별자를 제외하고 모듈에 의해 정의된 모든 식별자가 XML 인코딩에서 정규화되는 XML namespace를 정의.
  "namespace"문의 인수는 namespace의 URI이다.

- The "prefix" Statement

  "prefix"문은 모듈 및 해당 namespace와 관련된 접두사를 정의하는데 사용됨. (ex "if":"ifName")
  모듈 자체의 접두사를 포함한 모든 접두사는 모듈 또는 하위 모듈 내에서 고유해야한다.

- The "import" Statement

  "import"문은 한 모듈의 정의를 다른 모듈 또는 하위 모듈 내에서 사용할 수 있도록한다.
  "import"의 "revision-date"문은 가져올 모듈의 버전을 지정하는데 사용됨.

- The "include" Statement
  "include"문은 해당 하위 모듈의 상위 모듈에서 사용할 수 있는 하위 모듈의 콘텐츠를 만드는데 사용됨.

**1.3.3.2 The "container" Statement**
"Container"문은 스키마 트리에서 내부 데이터 노드를 정의하는데 사용됨.
하나의 인수(식별자)와 자세한 컨테이너 정보를 보유하는 하위 문 블록이 뒤따른다.
"container" 노드에는 값이 없지만 데이터 트리에 자식 노드 목록이 있다. 자식 노드는 컨테이너의 하위 문에 정의되어 있다.

- Containers with Presence(존재 하는 Containers)
  YANG은 **1. 데이터 노드의 계층 구조를 구성하기 위해서만 존재하는 컨테이너**와 **2. 데이터 트리에 명시적인 의미가 있는 컨테이너**의 두 가지 스타일을 지원한다.

  첫번째 스타일에서 컨테이너는 자체의 의미가 없으며 하위 노드만 포함하기 위해 존재한다.
  특히, 자식노드가 없는 컨테이너 노드의 존재는 컨테이너 노드가 없는 것과 의미상 동일. -> 비존재 컨테이너

  두번쨰 스타일에서 컨테이너 자체의 존재는 단일 비트 데이터를 나타내는 몇 가지 의미를 전달한다.
  config data의 경우 컨테이너는 구성 knob 및 관련 config node를 구성하는 수단의 역할을 한다.
  이러한 컨테이너는 명시적으로 생성 및 삭제 된다. -> 존재 컨테이너

- The "must" Statement
  "must"문은 XPath 표현식을 포함하는 문자열을 인수로 받는다.
  유효한 데이터에 대한 제약을 공식적으로 선언하는데 사용됨
  모든 제약은 데이터가 유효하려면 "true"로 평가되어야 한다.

- The must's Substatements

  - The "error-message" Statement
    "error-message"문은 문자열을 인수로 사용함.
    제약 조건이 "false"로 평가되면 NETCONF의 "rpc-error"에서 문자열이 "error-message"로 전달됨.
  - The "error-app-tag" Statement
    "error-app-tag"문은 문자열을 인수로 사용함.
    제약조건이 "false"로 평가되면 문자열이 NETCONF의 "rpc-error"에서 문자열이 "error-app-tag"로 전달됨.

  ```c
  container interface {
    leaf ifType {
      type enumeration {
        enum ethernet;
        enum atm;
      }
    }
    leaf ifMTU {
      type uint32;
    }
    must 'ifType != "ethernet" or ifMTU = 1500' {
      error-message "An Ethernet MTU must be 1500";
    }
    must 'ifType != "atm" or'
       + ' (ifMTU <= 17966 and ifMTU >= 64)' {
      error-message "An ATM MTU must be 64 .. 17966";
    }
  }
  ```

- The "presence" Statement

  "presence"문은 데이터 트리에서 컨테이너의 존재를 의미한다. 노드의 존재가 의미하는 바에 대한 텍스트 설명이 포함된 문자열을 인수로 받는다.

  컨테이너에 "presence"문이 있는 경우 데이터 트리에서 컨테이너의 존재는 몇가지 의미를 전달한다. 그렇지 않으면 컨테이너는 데이터에 어떤 구조를 제공하는데 사용되며 그 자체로는 의미가 없다.

- The container;s Child Node Statements

  컨테이너 내에서 "container", "leaf", "list", "leaf-list", "uses", "choice", "anydata", "anyxml" 문을 사용하여 컨테이너에 자식노드를 정의할 수 있다.

- NETCONF "edit-config" Operations

  컨테이너의 XML 요소에서 "operation"속성을 사용하여 "edit-config"를 통해 컨테이너를 생성, 삭제, 교체 및 수정 할 수 있다.

  컨테이너에 "presence"문이 없고 마지막 자식 노드가 삭제되면 NETCONF 서버는 컨테이너를 삭제할 수 있다.

  NETCONF 서버가 "edit-config" 요청을 처리할 때 컨테이너 노드에 대한 프로시저 요소는 다음과 같다.

  1. operation이 "merge"또는 "replace"인 경우 노드가 없으면 생성됨.
  2. operation이 "create"인 경우 노드가 없으면 생성, 노드가 없으면 "data-exists" 오류 리턴.
  3. operation이 "remove"인 경우 노드가 있으면 삭제, 노드가 없으면 "data-missing" 오류 리턴.

```c
Given the following container definition:

  container system {
    description
      "Contains various system parameters.";
    container services {
      description
        "Configure externally available services.";
      container "ssh" {
        presence "Enables SSH";
        description
          "SSH service-specific configuration.";
        // more leafs, containers, and stuff here...
      }
    }
  }

A corresponding XML instance example:

  <system>
    <services>
      <ssh/>
    </services>
  </system>

Since the <ssh> element is present, SSH is enabled.

To delete a container with an <edit-config>:

  <rpc message-id="101"
       xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"
       xmlns:nc="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
      <target>
        <running/>
      </target>
      <config>
        <system xmlns="urn:example:config">
          <services>
            <ssh nc:operation="delete"/>
          </services>
        </system>
      </config>
    </edit-config>
  </rpc>
```

**1.3.3.3 The "leaf" Statement**
leaf의 기본값은 데이터 트리에 leaf가 없는 경우 서버가 사용하는 값.
기본값의 사용은 존재하지 않는 컨테이너가 아닌 스키마 트리에서 leaf의 가장 가까운 상위 노드에 따라 다름.
조상 노드가 스키마트리에 존재하지 않으면 기본값을 사용함.
조상 노드가 데이터트리에 존재하지 않으면 기본값을 사용함.
조상이 케이스 노드인 경우, 케이스 노드가 데이터 트리에 존재하거나 케이스 노드가 선택의 기본 케이스이고, 데이터 트리에 다른 케이스의 노드가 존재하지 않는 경우 기본값을 사용해야 함.

- The leaf's "type" Statement
  반드시 존재해야하는 "type"문은 기존 내장 또는 파생 유형의 이름을 인수로 사용함.

- The leaf's "default" Statement
  선택적인 "default"문은 리프의 기본값을 포함하는 문자열을 인수로 사용함.
  "default"문의 값은 leaf의 "type"문에 지정된 유형에 따라 유효해야 한다.
  기본값의 정의는 "if-feature"문으로 표시되어서는 안된다. 

  ```c
  leaf color {
    type enumeration {
      enum blue { if-feature blue; }
      ...
    }
    default blue; // illegal - enum value is conditional
  }
  ```

- The leaf's "mandatory" Statement

  선택적인 "mandatory" 문은 "true" 또는 "false" 문자열을 인수로 사용하여 유효한 데이터에 대한 제약 조건을 설정.
  지정되지 않은 경우 "false".
  "mandatory"가 "true"이면 제약조건의 동작은 존재하지 않는 컨테이너가 아닌 스키마트리에서 리프의 가장 가까운 조상 노드 유형에 따라 달라짐.
  조상이 스키마 트리에 존재하지 않는 경우 리프가 존재해야함.
  조상이 케이스 노드인 경우, 케이스의 노드가 데이터 트리에 존재하면 리프가 존재해야함.
  데이터트리에 조상노드가 있으면 리프가 있어야함.

**1.3.3.4 The "leaf-list" Statement**
"leaf"문이 특정 유형의 단순 스칼라 변수를 정의하는데 사용되는 경우 "leaf-list"문은 특정 유형의 배열을 정의하는데 사용됨.
"leaf-list"문은 식별자인 하나의 인수와 자세한 leaf-list 정보를 보유하는 하위문 블록을 사용함.
구성데이터에서 leaf-list의 값은 고유해야함.
기본값의 정의는 "if-feature"문으로 표시되어서는 안됨.

- The leaf-list's "default" Statement
  선택적인 "default"문은 leaf-list의 기본값을 포함하는 문자열을 인수로 사용함.
  "default"문의 값은 리프 목록의 "type"문에 지정된 유형에 따라 유효해야함.
  "default"문은 "min-elements"가 1보다 크거나 같은 값을 갖는 노드에 존재하지 않아야함.
- The "min-elements" Statement
  선택적인 "min-elements"문은 유효한 목록 항목에 제약을 두는 음이 아닌 정수를 인수로 사용함.
  유효한 leaf-list 또는 list에는 최소한 최소 요소 항목이 있어야함.
  "min-elements"문이 없으면 기본값은 0.
  제약조건의 동작은 존재하지 않은 컨테이너가 아닌 스키마트리에서 leaf-list또는 list의 가장 가까운 조상노드의 유형에 따라 다름.
- The "max-elements" Statement
  선택사항인 "max-elements"문은 양의 정수 또는 유효한 list 목록 항목에 제한을 두는 문자열 "unbounded"인수로 사용함.
  유효한 leaf-list 또는 list에는 항상 최대 "max-elements"항목이 존재.
  "max-elements"문이 없는 경우 기본값은 "unbounded"
- The "order-by" Statement
  "order-by"문은 목록 내 항목의 순서가 사용자 또는 시스템에 의해 결정되는지 여부를 정의.
  인수는 "system" 또는 "user" 문자열 중 하나.
  ordering이 없는 경우 기본적으로 "system"으로 설정됨.

**1.3.3.5 The "list" Statement**
"list"문은 스키마 트리에서 내부 데이터 노드를 정의하는데 사용됨.
list 노드는 데이터 트리의 여러 인스턴스에 존재할 수 있다. 이러한 각 인스턴스를 list 항목이라고 함.
"list"문은 식별자인 하나의 인수와 세부 목록 정보를 보유하는 하위 블록을 사용함.
list 항목이 정의된 경우 list의 키 값으로 고유하게 식별됨.

**1.3.3.6 The "choice" Statement**
"choice"문은 데이터 트리당 하나의 대안 집합만 존재할 수 있다고 정의함.
인수는 식별자이며 세부적인 선택 정보를 보유하는 하위 문 블록이 뒤따른다. 식별자는 스키마 트리에서 선택노드를 식별하는데 사용됨.
데이터 트리에 choice 노드는 존재할 수 없다.

choice 항목은 각각 "case"하위 문으로 정의된 여러 분기로 구성된다.
각 분기에는 여러 하위 노드가 존재. 선택한 분기 중 최대 하나의 노드가 동시에 존재.
데이터 트리에서 언제든지 선택사례 중 하나만 유효할 수 있으므로 한 사례에서 노드를 생성하면 다른 모든 사례에서 모든 노드가 암시적으로 삭제됨. request가 케이스에서 노드를 생성하는 경우 서버는 선택항목 내의 다른 케이스에 정의된 기존 노드를 삭제.

# 2. libnetconf2 / libyang 이용

## 2.1 사용 라이브러리

libnetconf2 : https://github.com/CESNET/libnetconf2

netopeer2 : https://github.com/CESNET/Netopeer2

libyang : https://github.com/CESNET/libyang

sysrepo : https://github.com/sysrepo/sysrepo

![sysrepo](https://user-images.githubusercontent.com/50439622/100325237-aff87000-300b-11eb-80fa-c1d69b5e99b0.PNG)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림5. libnetconf2 / libyang 이용한 NETCONF 구조 



## 2.2 How to Configure the NETCONF Protocol(Cisco)

### 2.2.1 Providing Privilege Access to Use NETCONF

NETCONF API 작업을 시작하려면 user의 privilege level이 반드시 15이어야 한다. 

**SUMMARY STEPS**

1. enable
2. configure terminal
3. username "name" privilege "level" password "password"
4. aaa authentication login default local "and" aaa authorization exec default local
5. end

**DETAILED STEPS**

> **Step 1** 
> Device# enable
>
> **Step 2**
> Device# configure terminal
>
> **Step 3**
> Device(config)# username handream privilege 15 password Qwe123!@#
>
> **Step 4**
> Device(config)# aaa authentication login default local
> Device(config)# aaa authentication exec default local
>
> **Step 5**
> Device(config)# end

### 2.2.2 Configuring NETCONF-YANG

Device에서 legacy NETCONF protocol이 enable된 경우 RFC-compliant NETCONF는 동작하지 않는다.
**no netconf legacy** command 사용하여 legacy NETCONF protocol을 disable해야 한다.

**SUMMARY STEPS**

1. enable
2. configure terminal
3. netconf-yang
4. netconf-yang feature candidate-datastore
5. exit

**DETAILED STEPS**

>**Step 1**
>Device > enable
>
>**Step 2**
>Device# configure terminal
>
>**Step 3**
>Device(config)# **netconf-yang**
>
>> 네트워크 장치에서 NETCONF interface 활성화
>>
>> note. CLI를 통한 초기 활성화 후 모델 기반 인터페이스를 통해 네트워크 장치를 관리할 수 있다.
>> 모델 기반 인터페이스 프로세스의 전체 활성화에는 최대 90초가 소요될 수 있다.
>
>**Step 4**
>Device(config)# **netconf-yang feature candidate-datastore**
>
>> Enables candidate datastore.
>
>**Step 5**
>Device(config)# exit

### 2.2.3 Configuring NETCONF Options (CISCO IOS 기반)

**Configuring SNMP**

IOS(CISCO OS)에서 SNMP 서버를 enable 하여 NETCONF가 지원되는 MIB에서 생성 된 YANG 모델을 사용하여 SNMP MIB 데이터에 액세스할 수 있도록하고 IOS에서 지원되는 SNMP 트랩을 활성화 하여 지원되는 트랩에서 NETCONF 알림을 수신할 수 있도록 한다.

**SUMMARY STEPS**

1. Enable SNMP features in IOS
2. NETCONF-YANG이 시작된 후 RPC "edit-config" 메시지를 NETCONF-YANG 프트로 전송하여 SNMP 트랩지원을 활성화
3. NETCONF-YANG 포트에 다음 RPC 메시지를 보내 running configuration을 startup configuration에 저장.

**DETAILED STEPS**

> **Step  1**
> Enable SNMP features in IOS.
>
> ```
> configure terminal
> logging history debugging
> logging snmp-trap emergencies
> logging snmp-trap alerts
> logging snmp-trap critical
> logging snmp-trap errors
> logging snmp-trap warnings
> logging snmp-trap notifications
> logging snmp-trap informational
> logging snmp-trap debugging
> !
> snmp-server community public RW
> snmp-server trap link ietf
> snmp-server enable traps snmp authentication linkdown linkup 
> snmp-server enable traps syslog
> snmp-server manager
> exit
> ```
>
> **Step 2**
> NETCONF-YANG이 시작된 후 다음 RPC "edit-config" 메시지를 NETCONF-YANG 포트로 전송하여 SNMP 트랩 지원은 활성화
>
> ```XML
> <?xml version="1.0" encoding="utf-8"?>
> <rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="">
>   <edit-config>
>     <target>
>       <running/>
>     </target>
>     <config>
>       <netconf-yang xmlns="http://cisco.com/yang/cisco-self-mgmt">
>         <cisco-ia xmlns="http://cisco.com/yang/cisco-ia">
>           <snmp-trap-control>
>             <trap-list>
>               <trap-oid>1.3.6.1.4.1.9.9.41.2.0.1</trap-oid>
>             </trap-list>
>             <trap-list>
>               <trap-oid>1.3.6.1.6.3.1.1.5.3</trap-oid>
>             </trap-list>
>             <trap-list>
>               <trap-oid>1.3.6.1.6.3.1.1.5.4</trap-oid>
>             </trap-list>
>           </snmp-trap-control>
>         </cisco-ia>
>       </netconf-yang>
>     </config>
>   </edit-config>
> </rpc>
> ```
>
> **Step 3**
> NETCONF-YANG 포트에 다음 RPC 메시지를 보내 running configuration을 startup configuration에 저장
>
> ```xml
> <?xml version="1.0" encoding="utf-8"?>
> <rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="">
>   <cisco-ia:save-config xmlns:cisco-ia="http://cisco.com/yang/cisco-ia"/>
> </rpc>
> ```

### 2.2.4 Verifying the NETCONF Protocol Configuration

**SUMMARY STEPS**

1. show netconf-yang datastores
2. show netconf-yang sessions
3. show netconf-yang sessions detail
4. show netconf-yang statistics
5. show platform software yang-management process

**DETAILED STEPS**

> **Step 1**
> Device# **show netconf-yang datastores**  : NETCONF-YANG 데이터 스토어에 대한 정보를 표시
> Datastore Name : running
> Globally Locked By Session : 42
> Globally Locked Time : 2018-01-15T14:25:14-05:00
>
> **Step 2**
> Device# **show netconf-yang sessions** : NETCONF-YANG 세션에 대한 정보를 표시
> R: Global-lock on running datastore
> C: Global-lock on candidate datastore
> S: Global-lock on startup datastore
> Number of sessions : 10
> session-id transport username source-host global-lock
>
> 40 netconf-ssh admin 10.85.70.224 None
> 42 netconf-ssh admin 10.85.70.224 None
> 44 netconf-ssh admin 10.85.70.224 None
> 46 netconf-ssh admin 10.85.70.224 None
> 48 netconf-ssh admin 10.85.70.224 None
> 50 netconf-ssh admin 10.85.70.224 None
> 52 netconf-ssh admin 10.85.70.224 None
> 54 netconf-ssh admin 10.85.70.224 None
> 56 netconf-ssh admin 10.85.70.224 None
> 58 netconf-ssh admin 10.85.70.224 None
>
> **Step 3**
> Device# **show netconf-yang sessions detail** : NETCONF-YANG 세션에 대한 자세한 정보를 표시
> R: Global-lock on running datastore
> C: Global-lock on candidate datastore
> S: Global-lock on startup datastore
>
> Number of sessions     : 1
>
> session-id             : 19
> transport              : netconf-ssh
> username               : admin
> source-host            : 2001:db8::1
> login-time             : 2018-10-26T12:37:22+00:00
> in-rpcs                : 0
> in-bad-rpcs            : 0
> out-rpc-errors         : 0
> out-notifications      : 0
> global-lock            : None
>
> **Step 4**
> Device# **show netconf-yang statistics** : NETCONF-YANG 상태에 대한 정보를 표시
> netconf-start-time : 2018-01-15T12:51:14-05:00
> in-rpcs : 0
> in-bad-rpcs : 0
> out-rpc-errors : 0
> out-notifications : 0
> in-sessions : 10
> dropped-sessions : 0
> in-bad-hellos : 0
>
> **STEP 5**
> Device# **show platform software yang-management process**
> confd            : Running 
> nesd             : Running 
> syncfd           : Running 
> ncsshd           : Running 
> dmiauthd         : Running 
> vtyserverutild   : Running 
> opdatamgrd       : Running 
> nginx            : Running 
> ndbmand          : Running 
>
> > note : ip http secure-server 또는 ip http 서버가 장치에 구성된 경우 nginx 프로세스가 실행됨.
> > NETCONF가 제대로 작동하려면 이 프로세스가 실행 상태일 필요는 없다.
> > 다만, RESTCONF에는 nginx 프로세스가 필요.
> >
> > 표1. Cisco NETCONF 관련 daemon
> >
> > | Field          | Description                                            |
> > | :------------- | :----------------------------------------------------- |
> > | confd          | Configuration daemon                                   |
> > | nesd           | Network element synchronizer                           |
> > | syncfd         | Sync from daemon                                       |
> > | ncsshd         | NETCONF Secure Shell(SSH) daemon                       |
> > | dmiauthd       | Device management interface(DMI) authentication daemon |
> > | vtyserverutild | VTY server util daemon                                 |
> > | opdatamgrd     | Operation Data Manager daemon                          |
> > | nginx          | NGINX web server                                       |
> > | ndbmand        | NETCONF database manager                               |
> >
> > 

---



# 3. YumaPro SDK INSTALLATION

원문 출처 : https://www.yumaworks.com/support/download-documentation/

## 3.1 Installing YumaPro SDK

ubuntu 18.04 LTS 에서 testing

## 3.2 External Package Needed by the Server

```shell
mydir> sudo apt-get install libxml2-dev
```

일부 XML 구문 분석 기능에 필요. Linux 내에 default로 설치되어 있지만, YumaPro를 빌드하려면 DEB 기반의 libxml2-dev라는 개발자 패키지가 필요함.

```shell
mydir> sudo apt-get install openssh-server
```

SSH를 통한 NETCONF 지원을 위해 netconfd-pro 서버에 필요.
/etc/ssh/sshd_config 파일이 구성되면 SSH 서버 restart해야 netconfd-pro 서버가 작동함.

```shell
mydir> sudo apt-get install libcurl4-gnutls-dev
```

netconfd-pro 서버에서 FTP 또는 TFTP URL로 < copy-config >를 지원하는데 필요.

## 3.3 External Packages Needed by the Client

```shell
mydir> sudo apt-get install libssh2-1-dev
```

SSH 프로토콜을 사용하여 NETCONF 서버에 연결하려면 필요.

```shell
mydir> sudo apt-get install libncurses5-dev
```

일부 터미널 지원에 필요.

```shell
mydir> sudo apt-get install zlib1g-dev
```

YumaPro가 가져오는 다른 라이브러리에서 사용하는 데이터 압축 지원에 필요.

## 3.4 YumaPro Packages

https://www.yumaworks.com/support/download-yumapro-sdk-basic/yumapro-sdk-basic-downloads/

Ubuntu 18.04 AMD/Intel 64-bit : [yumapro-sdk-basic-19.10-12.u1804.amd64.deb](https://www.yumaworks.com/download/yumapro-sdk-basic-19-10-12-u1804-amd64-deb/) 다운로드

이후 받은 .deb 파일 설치해주어야 한다.

```shell
mydir> sudo dpkg -i /<다운로드_경로>/yumapro-sdk-basic-19.10-12.u1804.amd64.deb
```

### 3.4.1 Start the netconfd-pro server

```shell
etc/yumapro/netconfd-pro-sample.conf
```

이 파일에 구성 매개변수에 대한 모든 기본 설정이 포함되어 있다.

처름 YumaPro에서 제공하는 .con 파일은 '-sample'이라는 명칭이 붙어있기 때문에 파일명을 변경할 필요가 있다.

```shell
mydir> sudo cp /etc/yumapro/netconfd-pro-sample.conf /etc/yumapro/netconfd-pro.conf
mydir> sudo emacs /etc/yumapro/netconfd-pro.conf
```

## 3.5 Configure SSH

서버를 사용하기 위해서는 /etc/ssh/sshd_config 파일의 수정과 netconf subsystem 파일 추가가 필요하다.

```shell
mydir> sudo emacs /etc/ssh/sshd_config
```

NETCONF 서버를 시작하려면 sshd 서버가 실행 중인지 확인하고 구성이 **/etc/ssh/sshd_config**에 포함되어 있는지 확인할 필요가 있다. /etc/ssh/sshd_config에 아래 3줄 추가(초기 파일에 Port 22는 주석처리 되어있음.)

```
Port 22
Port 830
Subsystem netconf /usr/sbin/netconf-subsystem-pro
```

'Port 22' 명령은 SSH 서버가  NETCONF 세션 외에도 SSH 세션을 허용하는지 확인하는데 필요.

- **Installing SSH keys**

  ```
  mydir> ssh-keygen
  ```

  YumaPro SDK는 SSH 를 제공한다.

  ```
  mydir> ssh-copy-id <your_username>@<server's IP address>
  ```

  이 프로세스는 public / private key를 만든다. public key는 서버에 있어야 함.

- **Restart the SSH Server**

  ```shell
  > sudo service ssh restart
  ```

  또는

  ```shell
  > /etc/init.d/sshd restart
  ```


## 3.6 Start netconfd-pro

start the **netconfd-pro** server

```shell
> netconfd-pro --log-level=debug4 --access-control=off


> /usr/sbin/netconfd-pro --superuser=<username>
```

원하는 방식으로 수행하도록 서버를 조정하는데 사용할 수 있는 많은 매개변수가 있다.
--log-level : 가장 자세한 디버그 메시지 수준으로 서버 시작
--access-control : 서버가 수행하는 작업을 모니터링하고 액세스 제어를 비활성화(NETCONF 액세스 제어를 설정하지 않고도 YANG 데이터 조작 가능)

- **Server Startup Issues**

  이전에 netconfd-pro 서버를 실행한 적이 있고 아래 메시지가 표시되는 경우 서버가 다른 프로세스에서 계속 실행중이거나 마지막으로 실행되었을 때 완전히 종료되지 않았을 확률이 높다.
  실행중인 다른 서버를 중지하거나 메시지의 지침에 따라 이전 실행에서 남은 파일 정리 이후 재수행 되어야 한다.

  ```
  Error: program netconfd-pro appears to be running as PID 5125
  Error: Cannot create PID file
  *** If no other instances of netconfd-pro are running,
  *** try deleting /tmp/ncxserver.sock and $HOME/.yumapro/netconfd-pro.pid
  *** > rm /tmp/ncxserver.sock
  *** > rm $HOME/.yumapro/netconfd-pro.pid
  netconfd-pro: init returned (operation failed)
  Server Cleanup Starting...
  
  >sudo rm /tmp/ncxserver.sock
  >sudo rm $HOME/.yumapro/netconfd-pro.pid
  ```


**NETCONF SERVER 실행 시 유의 사항**

- netconfd-pro가 호출될 때 사용중인 현재 작업 디렉토리가 중요.
- netconfd-pro를 백그라운드에서 실행하고 모든 출력을 로그 파일에 저장하는 것이 가장 편리
- netconfd-pro 프로그램은 /tmp/ncxserver.sock에 있는 로컬 소켓에서 연결 요청을 수신
- NETCONF 세션을 활성화 하려면 SSH 서버 및 netconf-subsystem 프로그램이 적절하게 설정되어 있어야함.
- netconfd-pro 프로그램은 SSH 프로토콜 메시지를 직접 처리하지 않음. 대신 SSH 하위 시스템으로 구현됨.
- netconfd-pro 서버에 동시에 연결할 수 있는 동시 SSH 세션 수는 제한될 수 있음.

**netconfd-pro 프로그램은 여러가지 방법으로 호출할 수 있다.**

- To get the current version and exit:

  ```
  netconfd-pro --version
  ```

- To get program help and exit:

  ```
  netconfd-pro --help
  netconfd-pro --help --brief
  netconfd-pro --help --full
  ```

- To start the server in the background, set the logging level to 'debug', and send logging messages to a log file

  ```
  netconfd-pro --log-level=debug --log=~/mylog &
  ```

- To start the server interactively, and send all log messages to STDOUT:

  ```
  netconfd-pro
  ```

- To start the server interactively, with a new log file:

  ```
  netconfd-pro --log=mylogfile
  ```

- To start the server interactively, and append to an existing log file:

  ```
  netconfd-pro --log=mylogfile --log-append
  ```

- To get parameters from a configuration file:

  ```
  netconfd-pro --config=/etc/yumapro/netconfd-pro.conf
  ```

## 3.7 yangcli-pro Connect

NETCONF 서버가 실행되면 클라이언트 세션을 수락함.
netconfd-pro를 localhost에서 대화식으로 실행하는 경우 새 터미널창을 시작하여 계속.

yangcli-pro 프로그램은 여러가지 방법으로 호출 할 수 있다.

- To start the client interactively, and send all log messages to STDOUT:

  ```
  yangcli-pro
  ```

- To get the current version and exit:

  ```
  yangcli-pro --version
  ```

- To get program help and exit:

  ```
  yangcli-pro --help
  yangcli-pro --help --brief
  yangcli-pro --help --full
  ```

- To set the logging level to 'debug'

  ```
  yangcli-pro --log-level=debug
  ```



각 yangcli-pro 프로그램 인스턴스는 한번에 1개의 NETCONF 세션을 실행할 수 있다.

'connect' 명령은 NETCONF 세션을 시작하는데 사용되는데 여기는 3개의 필수 parameter가 있다.

1. user : 사용할 시스템 (또는 SSH) 사용자 이름
2. server : 사용할 NETCONF 서버의 IP 주소 또는 DNS 이름
3. password : 사용할 암호 문자열

```shell
> connect server=localhost user=dylee password=dylee123
```

yangcli에서 connect하게 되면 서버 기능 및 기타 정보를 자세히 설명하는 서버의 'hello' 메시지가 표시된다.
서버가 실행중인 터미널 창에서 서버가 시작된 디버그 수준에 한해 표시되는 디버그 정보(디버그 정보는 1~4 level 로 분리됨)를 볼 수 있다.

이제 다음과 같은 일부 명령을 실행하여 YANG 데이터를 표시할 수 있다.

```
dylee@localhost> sget /netconf-state/sessions

Filling container /netconf-state/sessions:
RPC Data Reply 5 for session 3 [default]:
 
rpc-reply {
  data {
    netconf-state {
      sessions {
        session 3 {
          session-id 3
          transport ncm:netconf-ssh
          username dylee
          source-host 127.0.0.1
          login-time 2018-11-20T07:00:17Z
          in-rpcs 4
          in-bad-rpcs 0
          out-rpc-errors 0
          out-notifications 0
        }
      }
    }
  }
}

```

yangcli-pro 및 사용 가능한 명령에 대한 자세한 내용 : https://www.yumaworks.com/pub/docs/latest/pdf/yumapro-yangcli-manual.pdf

yangcli-pro 종료하려면 'quit' 명령어 사용

```
dylee@localhost> quit
```

NETCONF seesion을 종료하려면

```
dylee@localhost> close-session
```

NETCONF 서버를 종료하려면 < Ctrl > + c

## 3.8. Configure TLS

### 3.8.1 Server Setup

서버에 인증서 작업을 위한 두개의 디렉토리를 생성하고 generate-keys.sh 스크립트 파일을 복사.

(현재 나의 $HOME 환경변수 path는 /home/dylee 이다.)

```shell
> mkdir $HOME/buildcerts
> mkdir $HOME/certs
> cp /usr/share/yumapro/util/generate-keys.sh $HOME/buildcerts
```

buildcerts 디렉토리로 이동하여 키 생성 스크립트를 실행하고 파일이 생성되었는지 확인

```shell
> cd buildcerts
buildcerts> ./generate-keys.sh
buildcerts> ls -al
```

generate-keys.sh 스크립트는 'restconf' 사이트에 대한 키와 인증서를 생성함.
스크립트로 만든 키를 사용하여 restconf 사이트에 대한 TLS를 설정할 수 있음.

인증서 적절한 위치에 copy

```shell
buildcerts> sudo cp ca.crt /usr/local/share/ca-certificates/
buildcerts> cp server.crt ../certs/
buildverts> cp server.key ../certs/
```

/etc/ssl/certs 디렉토리로 이동하여 업데이트를 실행하고 결과 확인

```shell
buildcerts> cd /etc/ssl/certs
certs> sudo update-ca-certificates
certs> ls -l | grep ca.crt
```

update-ca-certificates 스크립트는 ca-certificates 패키지를 사용함.
시스템에 이 패키지가 없는 경우 아래의 단계에 따라 필수 인증서 링크가 생섬됨

```shell
buildcerts> mkdir temp
buildcerts> sudo ln -s /usr/local/share/ca-certificates/ca.crt temp/ca.pem
buildcerts> sudo c_rehash temp
 Doing temp
buildcerts> sudo mv temp/* /etc/ssl/certs
buildcerts> ls -l /etc/ssl/certs | grep ca.pem
 lrwxrwxrwx 1 root root 6 Mar 16 08:00 56c899cd.0 -> ca.pem
 lrwxrwxrwx 1 root root 6 Mar 16 08:00 b2457b50.0 -> ca.pem
 lrwxrwxrwx 1 root root 39 Mar 16 08:00 ca.pem -> /usr/local/share/ca-certificates/ca.crt
buildcerts>
```

클라이언트 Fingerprint 생성

```shell
certs> cd $HOME/buildcerts
buildcerts> openssl x509 -noout -fingerprint -sha1 -inform pem -in client.crt
SHA1 Fingerprint=F2:1D:B9:0F:BD:37:00:00:00:00:00:0:00:00:00:00:00:00:00:00:00
```

다음으로 netconfd-pro.conf 파일을 편집하여 TLS를 사용하는데 필요한 매개변수로 서버를 구성해야 함.
기존 netconfd-pro.conf가 있는 경우 "netconfd-pro { }" 내에 있는 네 개의 매개변수 줄을 기존 파일에 추가해야 함.
기존 netconfd-pro.conf 파일이 없는 경우 표시된 대로 편집기를 실행하면 netconfd-pro.conf 파일이 생성된 다음 표시된 행을 추가함.
※ netconfd-pro.conf에 필요한 cert-usermap 매개변수는 위의 단계의 dylee@F2:1D:B9:0F:BD:37

```shell
buildcerts> sudo emacs /etc/yumapro/netconfd-pro.conf
파일 편집기 사용하여 파일 열고 아래 네줄 추가

netconfd-pro {
  with-netconf-tls true
  netconf-tls-certificate ~/certs/server.crt
  netconf-tls-key ~/certs/server.key
  cert-usermap <YOUR_USERNAME>@<first_six_pairs_of_the_SHA1_Fingerprint>
}
```

### 3.8.2 Client Setup

클라이언트에서 인증서 작업을 위한 두 개의 디렉토리 생성

```shell
CLIENT:
mydir> mkdir $HOME/buildcerts
mydir> mkdir $HOME/certs

```

서버에서 sftp를 사용하여 생성한 파일을 클라이언트 시스템에 복사

```shell
SERVER:
mydir> cd $HOME/buildcerts
buildcerts> sftp CLIENT_USERNAME@CLIENT
sftp> cd buildcerts
sftp> put *
sftp> bye

```

클라이언트 인증서 적절한 위치에 복사

```shell
CLIENT:
mydir> cd $HOME/buildcerts
buildcerts> sudo cp ca.crt /usr/local/share/ca-certificates
buildcerts> cp client.crt $HOME/certs/
buildcerts> cp client.key $HOME/certs/

```

/etc/ssl/certs 디렉토리로 이동하여 업데이트 실행하고 결과 확인

```shell
CLIENT:
buildcerts> cd /etc/ssl/certs
certs> sudo update-ca-certificates
certs> ls -l | grep ca.crt
lrwxrwxrwx 1 root root 39 Mar 16 16:25 ca.pem -> /usr/local/share/cacertificates/ca.crt

```

다음으로 yangcli-pro.conf 파일을 편집하여 TLS를 사용하는데 필요한 매개변수로 클라이언트를 구성해야함.
기존 yangcli-pro.conf가 있는 경우 yangcli-pro { } 내에 있는 두 개의 매개변수 줄을 기존 파일에 추가

```shell
buildcerts> sudo <your_editor> /etc/yumapro/yangcli-pro.conf

Add the following two parameters:
yangcli-pro {
 ssl-certificate ~/certs/client.crt
 ssl-key ~/certs/client.key
}
```

- **Test the TLS Connection**

  ```shell
  SERVER:
  mydir> netconfd-pro log-level=debug4 access-control=off
  
  CLIENT:
  mydir> yangcli-pro
   ...
  > connect user=<andy> server=<SERVER_HOST> no-password transport=tls
  
  ```

  

## 3.9 Enable Notification Delivery

기본 NETCONF 알림 스트림은 **'create-subscription'**명령으로 시작할 수 있다.

```shell
dylee@localhost> create-subscription
```

NETCONF 서버내의 다른 활동에 따라 'sysSessionStart' 또는 'sysSessionEnd'와 같은 다른 알림 이벤트가 생성 될 수 있다. 알림은 전체적으로 표시되지만 'rpc reply ouput' 중에는 출력되지 않음.

## 3.10 Load the Toaster Module

Toaster 모듈은 핵심 시스템 모듈이 아니며 자동으로 사용할 수 없다.
모듈은 NETCONF 클라이언트에 의해 명시적으로 로드되어야 한다.

```shell
dylee@localhost> load toaster
```

모듈이 성공적으로 로드되면 로드된 토스터 모듈의 개정 날짜가 포함된 데이터 응답이 전송됨.
이 응답은 이미 로드된 경우에도 반환된다.
'sysCapabilityChange' 알림 이벤트는 모듈이 서버에 아직 로드되지 않은 경우에만 전송됨.
이 경우 이 세션에 대한 \<hello\> 메시지에 광고되지 않았으므로 Toaster 모듈을 로드해야 한다.

```shell
dylee@localhost> mgrload toaster
```

## 3.11 Enable the Toaster

```
dylee@localhost> make-toast (error 메시지 출력될 것임)

NETCONF 데이터베이스 노드 없이 make-toast 할 경우 rpc-error 메시지 출력.
```

make-toast command 사용하기 위해서는 NETCONF 데이터베이스 노드를 먼저 만들어야 한다.

- **Lock the Databases**

  먼저 쓰기를 위해 NETCONF 데이터베이스 잠금.

  ```shell
  dylee@localhost> get-locks
  ```

- **Create the toaster Container**

  toaster 모듈은 간단한 YANG 'presence' 컨테이너를 사용하여 toaster 서비스를 구성.
  /toaster 컨테이너가 생성되면 컨테이너 내의 읽기 전용 노드가 서버에 의해 유지되고 toaster 서비스가 활성화 됨.
  첫 단계는 \<candidate\> config 데이터베이스에 /toaster 노드를 만드는 것.

  ```shell
  dylee@localhost> create /toaster
  ```

- **Save the Database Changes**

  현재 세션의 데이터베이스 대상에 따라 **'commit'** 또는 **'copy-config'** 작업을 실행하는 high-level yangcli-pro 작업

  ```shell
  dylee@localhost> save
  ```

- **Unlock the Databases**

  ```
  dylee@localhost> release-locks
  ```

## 3.12 Get the Toaster State Information (GET Test)

토스터 모델과 현재 상태를 발견하기 위해 'sget' 또는 'xget' 명령을 사용하여 서버에서 사용 가능한 개념적 상태 데이터의 토스터 부분만 검색 할 수있다.
'sget' 명령은 **\<get\>** 작업에 대한 상위 수준의 **subtree filter** 처리기.

```shell
dylee@localhost> sget /toaster
```

'xget' 명령은 **\<get\>** 작업에 대한 상위 **XPath filter** 처리기.

```shell
dylee@localhost> xget /toster
```

두 명령어 모두 아래의 rpc-reply 결과가 반환되어야 한다.

```
rpc-reply {
  data {
    toaster {
      toasterManufacturer 'Acme, Inc.'
      toasterModelNumber 'Super Toastamatic 2000'
      toasterStatus up
    }
  }
} 
```

## 3.13 Start/Stop Making Toast (notification Test)

Toster 활성화되었으므로 'make-toast' 명령이 작동된다.
예제에서는 기본 매개변수 값 사용하는 대신 timer를 작동하여 40초 후에 frozen-waffle에 대한 'toastDone' 알림이 수행되도록 한다고 함.(직접 실행시 40초 대기 후 notification 컨테이너 통해 client로 전송됨)

```bash
dylee@localhost> make-toast toasterDoneness=4 toasterToastType=toast:frozen-waffle
```

```
40초 후 client가 받게 되는 data
Incoming notification:
  notification {
    eventTime 2009-12-29T01:20:05Z
    toastDone {
      toastStatus done
    }
  sequence-id 5
} 
```

'toastDone' 이벤트는 토스트가 완료되었으며 먹을 준비가 되었음을 보여줌 (하나의 notification 예제)

마음이 바뀌어 frozen-waffle 대신 wheat toast 가 먹고싶다고 한다.

```shell
dylee@localhost> make-toast toasterDoneness=4 toasterToastType=toast:frozen-waffle
```

command 명령어 수행 후 40초 이후 notification 오기전에

```
dylee@localhost> cancel-toast   ===> 수행

Incoming notification:
  notification {
    eventTime 2009-12-29T01:24:36Z
    toastDone {
      toastStatus cancelled
    }
    sequence-id 6
  } 
}
```

'toastDone' 이벤트는 토스트가 취소되었음을 알린다.

# 4. YumaPro SDK Advanced Topics

## 4.1 Data Retrieval

- **Basic NETCONF Retrieval Operations**

  NETCONF 프로토콜에는 두 가지 검색작업이 있다.

  1. **\<get\>** : 상태 데이터와 running configuration database를 가져온다.
  2. **\<get-config\>** : 지정된 configuration database만 가져온다.

  

  각 작업은 두 가지 형식이 있는 \<filter\> 매개변수를 이용한다.

  1. **subtree filter** : 필터의 XML subtree와 일치하는 데이터베이스의 subtree만 검색

  2. **XPath filter** : 지정된 XPath 표현식을 비교하여 생성된 결과 노드 세트와 일치하는 subtree만 검색

     ※ 이 모드는 서버에서 :xpath 기능을 알려야하는 경우가 아니면 사용 불가. 

  

  yang-cli 프로그램은 각 명령의 세가지 형식을 지원

  1. **plain** : 사용자 제공 필터를 사용한 일반 NETCONF 작업
2. **subtree** : XPath 경로 표현식 또는 사용자 변수를 통해 \<filter\> parameter의 **subtree XML**에 대해 XML로 변환됨
  3. **xpath** : XPath 경로 표현식 또는 사용자 변수를 통해 \<filter\> parameter의 **'select' XML**에 대해 XML로 변환됨

  

  표2. netconf get operation에 대한 설명

  | command         | description                          | example                                                 |
  | --------------- | ------------------------------------ | ------------------------------------------------------- |
  | **get**         | plain \<get\> operation              | get with-defaults=trim                                  |
  | **get-config**  | plain \<get-config\> operation       | get-config source=candidate                             |
  | **sget**        | \<get\> with a subtree filter        | sget /system                                            |
  | **sget-config** | \<get-config\> with a subtree filter | sget-config source=running /nacm/rules                  |
  | **xget**        | \<get\> with an XPath filter         | xget "//interface/counters"                             |
  | **xget-config** | \<get-config\> with an XPath filter  | xget-config source=candidate "//interface[name='eth0']" |

  검색 명령은 요청된 XML subtree를 포함하는 \<data\>라는 요소를 반환한다.

  reply에서 데이터를 구별하기 위해 식별자 노드(YANG key leafs)가 필요한 경우에는 서버에서 필요에 따라 추가된다.
  'xget' example에서 XPath 표현식을 직접 요청하지 않더라도 각 interface에 대한 \<name\> parameter가 반환된다.

  

- **Default Value Filtering**

  \<with-defaults\> parameter가 명령에 추가되지 않는한 데이터는 서버의 기본값 처리 동작에 따라 필터링 된다.

  이 parameter는 서버가 'with-defaults' 기능을 알리는 경우에만 지원된다. (그렇지 않은 경우 client는 수행중인 기본값 필터링 유형을 서버에 표시하진 않음)

  1. **report-all-tagged** : no-filtering -- 서버에 의해 기본값으로 간주되기 때문에 서버가 억제할 수 있는 모든 노드를 반환한다. (기본적으로 설정된 노드에는 'default' XML 속성이 추가됨)

  2. **report-all** : no-filtering -- 서버에 의해 기본값으로 간주하기 때문에 서버가 일반적으로 억제할 수 있는 모든 노드를 반환한다.

  3. **trim** : 스키마 정의된 기본 값과 일치하는 leaf 노드를 제외한 모든 노드를 반환한다.

  4. **explicit** : 값이 스키마 정의 기본값인 경우에도 client 또는 server에서 설정한 모든 노드를 특정 값으로 반환한다.(일반적으로 **netconf-proxy** server의 기본 동작)

     

- **Special Retrieval Operation**

  모든 YANG 모듈은 'rpc'문을 사용하여 새 작업을 추가할 수 있다. 

  

  표3. netconfd-pro에서 지원하는 두 가지 사용자 지정 검색작업
  
  | operation          | description                                                  |
  | ------------------ | ------------------------------------------------------------ |
| **get-schema**     | 서버에서 알리는 모듈 중 하나에 대한 YANG 또는 YIN 소스파일을 검색<br />ietf-netconf-monitoring 모듈에 정의된 표준 작업. |
  | **get-my-session** | 나의 세션에 대한 사용자 정의 가능한 설정을 검색<br />yuma-my-session 모듈에 정의된 독점 작업 |
  
  

## 4.2. Notifications

notification은 NETCONF에서 client(application)에 server 이벤트 정보를 보내는데 사용된다. <br />세션은 **'create-subscription' 명령**으로 알림을 요청한다. <br />

- **Notification Contents**

  이 요소의 child 노드는 알림 콘텐츠를 구성하며 3개의 섹션으로 나뉜다.

  1. **event generation time-stamp** <br />이 표준 NETCONF leaf는 항상 알림 요소 내의 첫번째 child 요소이다.

  2. **event payload** <br />모듈 별 이벤트 페이로드는 알림 이름이 있는 컨테이너로 표시된다.<br />YANG 알림 문에 정의된 모든 데이터 노드는 이벤트 유형 컨테이너의 child 노드로 순서대로 나타난다.

  3. **proprietary extensions** <br />이벤트 페이로드 요소 뒤에 0 개 이상의 공급업체별 요소가 나타날 수 있다. 예를 들어 'sequence-id' 요소가 **netconfd-pro** 이벤트 로그에 저장된 각 알림에 추가된다.

     

- **Notification Replay**

  netconfd-pro 서버의 경우 알림 이벤트 기능은 --evnetlog-size 매개변수로 설정되는 구성가능한 기능이다.<br />netconfd-pro의 기본값은 최근 1000개의 알림 이벤트를 저장. 시스템 이벤트만 저장되며, 'replyComplate', 'subscriptionComplete' 이벤트는 세션 별 이벤트 이므로 재생 버퍼에 저장되지 않는다.

  'create-subscription' 명령에는 저장된 알림이 client 세션에 전달되도록 요청하는 2개의 매개변수가 존재

  1. **startTime**
  2. **stopTime**

## 4.3 Database Editing

NETCONF는 여러 개념적 configuration database를 지원한다. 'running' database만 실제로 활성화 되고 다른 모든 database는 off-line 상태이다.

모든 NETCONF 서버는 \<edit-config\> 작업을 통해 구성에 대한 임의의 부분 편집을 허용한다.

NETCONF 데이터베이스 edit의 기본적인 절차

1. 데이터베이스 잠금 (command : **get-locks**)
2. **\<edit-config\>** 또는 **\<copy-config\>** 통해 database 변경
3. database 편집 활성화하고 저장 (command: **/create \<module name\>** -> **save**)
4. 데이터베이스 잠금 해제 (command : **release-locks**)

- **The Target Database**

  일반적으로 NETCONF 서버는 candidate 또는 running database 중 하나의 database에서만 **\<edit-config\>** 작업을 지원한다. 이를 'target' database라고 하며 **\<edit-config\>** 작업의 **\<target\>** parameter에 해당한다.

  target database가 candidate configuration인 경우 **\<edit-config\>** 작업이 항상 가능한 모든 database 유효성 검사를 서버에서 수행하는 것은 아님. 이런 'final validation' 검사는 **\<commit\>** 작업이 호출 될 때만 수행한다.

- **Non-Volatile Storage**

  startup configuration은 NETCONF 서버를 다시 부팅할 때 사용되는 개념적 database이다. NETCONF 서버가 :startup 기능을 지원하는지 여부를 아는것이 중요하다. operator는 **\<copy-config\>** 작업을 사용하여 running database를 non-volatile 저장소에 명시적으로 저장해야 한다.

  ynagcli-pro 프로그램에는 편집 작업 후에 사용되는 **'save' command**가 있으며, 이 명령은 자동으로 올바른 프로토콜로 작업을 실행하여 편집을 완료하고 변경 사항을 non-volatile 저장소에 저장한다.

  startup database는 netconfd-pro 서버에서 구성할 수 있다. **--with-startup** configuration parameter는 startup database의 사용여부를 제어한다.

  startup parameter를 사용하여 running configuration의 초기 로드를 세가지 방법으로 제어할 수 있다.

  1. **no startup** : 이 단계 skip하고 factory default 사용
  2. **default startup** : 구성된 데이터 경로에서 기본 startup-cfg.xml 파일 사용 (filepath : **/$HOME/.yumapro**)
  3. **specific startup** : 지정된 파일, 구성된 데이터 경로의 상대경로 사용

## 4.4 System Configuration

YumaPro 프로그램은 YANG을 사용하여 구성 매개변수를 정의.

'ncx : cli' 확장자는 모든 CLI 매개변수를 정의하기 위해 프로그램과 동일한 이름의 컨테이너 내에서 사용된다.<br />일부 매개변수는 공유되므로(yuma-app-common.yang 참조) 컨테이너에 직접 위치하지 않음.

YumaPro 에 대한 모든 구성 매개변수를 포함하는 다음 YANG 모듈이 제공된다.

- **yuma-types.yang** : YumaPro 응용프로그램에서 사용되는 일반적인 데이터 유형을 포함
- **yuma-app-common.yang** : 모든 YumaPro app에서 사용되는 공통 CLI 매개변수를 포함
- **yuma-ncx.yang** : YumaPro app 모듈을 포함하여 모든 YANG 모듈에서 사용되는 YANG 확장을 포함
- **yangdump-pro.yang** : yangdump-pro 응용 프로그램의 구성 매개변수
- **yangdiff-pro.yang** : yangdiff-pro 응용 프로그램에 대한 구성 매개변수 및 로컬 명령
- **yangcli-pro.yang** : yangcli-pro 응용 프로그램에 대한 구성 매개변수 및 로컬 명령
- **netconfd-pro.yang** : netconfd-pro 서버의 구성 매개변수

Note:

- **netconf-subsystem-pro** 파일에는 현재 구성 매개변수가 없으므로 YANG 파일이 정의되어 있지 않다.
- **openssh** SSH 서버는 **sshd_config** 파일을 사용하여 별도로 구성된다.

YumaPro application은 다음 순서로 확인되는 3가지 소스의 구성 매개변수를 수용할 수 있다.

1. environment variables
2. command line parameters
3. configuration file

### 4.4.1 Environment Variables

YumaPro 프로그램은 시스템 환경변수를 활용하여 프로그림의 구성 및 작동을 사용자 정의 하고 단순화한다.<br />이러한 환경변수는 일번적으로 파일 검색 경로 또는 기본 디렉토리 위치를 지정한다.

- **$HOME**

  $HOME 환경변수는 사용자 홈 디렉토리의 디렉토리 사양을 포함하며 사용하기 전에 시스템 쉘에서 설정해야함.<br />YumaPro 프로그램은 이 디렉토리에 포함된 하위 디렉토리와 파일을 읽고 쓸 수 있음.

  Default value : none<br />CLI override : none<br />C shell example:

  ```shell
  setenv HOME /home/dylee
  ```

  Bash shell example:

  ```bash
  export HOME=/home/dylee
  ```

- **$YUMAPRO_HOME** (OpenYuma에서도 동일하기 때문에 OpenYuma 디렉토리 기준으로  경로 설정함)

  $YUMAPRO_HOME 환경변수에는 현재 YumaPro 프로젝트 루트 디렉토리의 디렉토리 사양이 포함됨.<br />YumaPro 소소 트리 내의 'netconf' 디렉토리 경로

  Default value : none<br />CLI override : --yuma-home<br />CLI example :

  ```cli
  --yuma-home=/home/dylee/Openyuma_master/netconf
  ```

  C shell example:

  ```c shell
  setenv YUMAPRO_HOME /home/dylee/Openyuma_master/netconf
  ```

  Bash shell example

  ```bash
  export YUMAPRO_HOME=/home/dylee/Openyuma_master/netconf
  ```

- **$YUMAPRO_INSTALL** (따로 설정하지 않았음)

  YumaPro 설치 루트 디렉토리의 디렉토리 사양이 포함됨

  Default value : /usr/share/yumapro<br />CLI override : none<br />C shell example :

  ```c shell
  setenv YUMAPRO_INSTALL /sw/yumapro
  ```

  Bash shell example :

  ```bash
  export YUMAPRO_INSTALL=/sw/yumapro
  ```

- **$YUMAPRO_MODPATH** (따로 설정하지 않았음)

  YANG 또는 YIN 모듈 및 하위 모듈을 찾기위해 검색해야하는 디렉토리 사양 목록이 포함되어 있다.<br /> 기본 위치를 넘어 검색 경로를 확장하는데 사용할 수 있다.

  Default value : none<br />CLI override : --modpath<br />CLI example : 

  ```cli
  --modpath="$HOME/modules2:/usr/local/modules"
  ```

  C shell example :

  ```c shell
  setenv YUMAPRO_MODPATH "$HOME/modules2:/usr/local/modules"
  ```

  Bash shell example:

  ```bash
  export YUMAPRO_MODPATH="$HOME/modules2:/usr/local/modules"
  ```

- **$YUMAPRO_LOADPATH** (따로 설정하지 않았음)

  YANG 또는 YIN 모듈을 서버에 로드하기 위해 검색해야하는 디렉토리 사양 목록이 포함되어 있다.<br />netconfd-pro 에서반 지원됨

  Default value : none<br />CLI override : --loadpath<br />CLI example : 

  ```cli
  --loadpath="$HOME/modules2"
  ```

  C shell example :

  ```c shell
  setenv YUMAPRO_LOADPATH "$HOME/modules2"
  ```

  Bash shell example:

  ```bash
  export YUMAPRO_LOADPATH="$HOME/modules2"
  ```

- **$YUMAPRO_DATAPATH** (따로 설정하지 않았음)

  YumaPro 응용 프로그램에서 사용하는 데이터 파일을 찾기 위해 검색해야 하는 디렉토리 사양 목록이 포함되어 있다.<br />기본 위치를 넘어 검색 경로를 확장하는데 사용할 수 있다.

  yangcli-pro 프로그램에서 사용하는 데이터 파일은 이 환경변수의 영향을 받는다.

  netconfd-pro 프로그램이 startup-cgf.xml 파일을 보관하는 위치도 이 환경 변수의 영향을 받는다. 이 파일에는 서버가 부팅될 때 < running > database로 로드되는 non-volatile < startup > database의 내용도 포함되어 있다.

  Default value : none<br />CLI override : --datapath<br />CLI example : 

  ```cli
  --datapath="$HOME/mydata:$HOME/project1/data"
  ```

  C shell example :

  ```c shell
  setenv YUMAPRO_DATAPATH "$HOME/mydata:$HOME/project1/data"
  ```

  Bash shell example:

  ```bash
  export YUMAPRO_DATAPATH="$HOME/mydata:$HOME/project1/data"
  ```

- **$YUMAPRO_RUNPATH** (따로 설정하지 않았음)

  YumaPro 응용 프로그램에서 사용하는 스크립트 파일을 찾기 위해 검색해야 하는 디렉토리 사양 목록이 포함되어 있다. 기본 위치를 넘어 검색 경로를 확장하는데 사용할 수 있다.

  Default value : none<br />CLI override : --runpath<br />CLI example : 

  ```cli
  --runpath="$HOME/scripts:/usr/local/scripts"
  ```

  C shell example :

  ```c shell
  setenv YUMAPRO_RUNPATH "$HOME/scripts:/usr/local/scripts"
  ```

  Bash shell example:

  ```bash
  export YUMAPRO_RUNPATH="$HOME/scripts:/usr/local/scripts"
  ```



-----



# 5. OpenYuma Developmet Manual

관련 docs : https://github.com/OpenClovis/OpenYuma/tree/master/netconf/doc/yuma_docs<br />관련 Open sourcee : https://github.com/OpenClovis/OpenYuma

OpenYume Development Manual에 대한 자세한 내용은 위의 링크[openyuma-dev-manual.odt](https://github.com/OpenClovis/OpenYuma/blob/master/netconf/doc/yuma_docs/openyuma-dev-manual.odt)를 참조하면 된다. Development Manual에는 NETCONF/YANG software 개발에 중점을 두고 있다. SIL(Server Instrumentation Library)에 대한 개념과 각 Source file에 대한 설명과 목적이 명시되어 있다. 또한, 각 module의 역할과 쓰임에 대해서 설명하고 있다.

## 5.1 What is a OpenYuma Root?

![image](https://user-images.githubusercontent.com/50439622/101724682-843cb600-3af2-11eb-8786-381659301d47.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림6. Yuma Root Directory

OpenYuma 도구 프로그램은 기본 위치에서 일부 유형의 파일을 검색한다.

- **YANG Modules** : 'modules' 하위 디렉토리는 YANG 모듈 라이브러리의 루트로 사용됨
- **Client Scripts** : yangcli 프로그램은 'scripts' 하위 디렉토리에서 사용자 스크립트를 찾는다.
- **Program Data** : yangcli 및 netconfd 프로그램은 'data' 하위 디렉토리에서 저장된 데이터 구조를 찾는다.

```
<Testing : YumaRoot 파일 경로>
$HOME = /home/dylee
Yuma Root = $HOME/OpenYuma-master/netconf/
```

### 5.1.1 Searching OpenYuma Roots

![image](https://user-images.githubusercontent.com/50439622/101725194-89e6cb80-3af3-11eb-8f10-fe1bf9cff7c7.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림7. 파일 검색을 위한 Yuma Roots 환경변수

- **$HOME Directory**

  파일을 검색할 때 처음으로 확인되는 OpenYuma 루트는 $HOME 환경변수로 식별되는 디렉토리이다.<br />**$HOME/modules**, **$HOME/data**, **$HOME/scripts** 디렉토리가 존재하면, 지정된 파일을 확인할 것이다.

  - **$HOME 환경변수 설정**

    $HOME 환경변수는 사용자 홈 디렉토리의 디렉토리 사양을 포함하며 사용하기 전에 시스템 쉘에서 설정해야함.<br />YumaPro 프로그램은 이 디렉토리에 포함된 하위 디렉토리와 파일을 읽고 쓸 수 있음.

    Default value : none<br />CLI override : none<br />C shell example:

    ```shell
    setenv HOME /home/dylee
    ```

    Bash shell example:

    ```bash
    export HOME=/home/dylee
    ```

- **$YUMA_HOME Directory**

  파일을 검색할때 확인되는 두번째 OpenYuma 루트는 **$YUMA_HOME** 환견변수로 식별되는 디렉토리이다.<br/>일반적으로 개인 작업 디렉토리로 사용되지만 공유 디렉토리로 사용될 수 도 있다.<br/>**$YUMA_HOME/modules**, **$YUMA_HOME/data**, **$YUMA_HOME/scripts** 디렉토리가 존재하면, 지정된 파일을 확인할 것이다.

  - **$YUMA_HOME**

    $YUMA_HOME 환경변수에는 현재 YumaPro 프로젝트 루트 디렉토리의 디렉토리 사양이 포함됨.<br />OpenYuma 소소 트리 내의 'netconf' 디렉토리 경로

    Default value : none<br />CLI override : --yuma-home<br />CLI example :

    ```cli
    --yuma-home=/home/dylee/Openyuma_master/netconf
    ```

    C shell example:

    ```c shell
    setenv YUMAPRO_HOME /home/dylee/Openyuma_master/netconf
    ```

    Bash shell example

    ```bash
    export YUMAPRO_HOME=/home/dylee/Openyuma_master/netconf
    ```

- **$YUMA_INSTALL Directory**

  파일을 검색할 때 마지막으로 확인 된 OpenYuma 루트는 **$YUMA_INSTALL** 환경변수로 식별되는 디렉토리이다.<br/>설정되어 있지 않으면 default value **'/usr/share/yuma'**가 대신 사용된다. 일반적으로 모든 사용자가 기본 모듈을 찾아야하는 공용 디렉토리로 설정된다.<br/>**$YUMA_INSTALL/modules**, **$YUMA_INSTALL/data**, **$YUMA_INSTALL/scripts** 디렉토리가 존재하면, 지정된 파일을 확인할 것이다.

### 5.1.2  What is a SIL ?

SIL은 Server Instrumentation 라이브러리이다. 여기에는 YANG 모듈 명령문에 정의된 대로 특정 동작을 구현하는 networking 장치에 YANG 콘텐츠(netconfd에서 관리)를 binding 하는 'glue code'가 포함되어 있다. <br/>**서버는 부팅 시 또는 runtime 시 로드되는 YANG파일을 직접 사용하여 모든 NETCONF 콘텐츠, 작업, 알림을 관리**한다.<br/>Callback 함수는 장치 및 데이터 모델 특정 동작을 데이터베이스 객체 및 RPC 작업에 연결하는데 사용된다. **yangdump 프로그램은 특정 YANG 모듈에 대한 initialization, cleanup, 'empty' callback 함수를 생성하는데 사용**된다. 'load' command 는 YANG 모듈과 SIL을 활성화 하기 위해 사용된다.

### 5.1.3 Basic Development Steps

OpenYuma 내에서 사용할 서버 instrumetation을 만드는데 필요한 단계.

1. YANG 모듈 데이터 모델 정의를 생성하거나, 기존 YANG 모듈을 사용<br/>yangdump 프로그램으로 YANG 모듈의 유효성을 검사하고 오류가 없는지 확인. 또한 모든 경고를 조사하여 데이터 모델링 버그를 나타내는지 여부를 확인해야한다.

2. **&YUMA_HOME** 환경변수가 정의되어 있고 OpenYuma 개발 트리를 가리키는지 확인

3. **SIL 개발 subtree 생성**<br/>**/usr/bin** 디렉토리에 설치된 **make_sil_dir** 스크립트를 사용하여 디렉토리 구조와 Makefile을 생성. 이 단계에서 **yangdump를 호출하여 SIL 초기 .h파일 및 .c 파일을 생성**한다.
4. 텍스트 편집기를 사용하여 각 object, RPC method, notification에 대한 장치 별 instrumenation을 채운다. 거의 모든 NETCONF 관련 코드는 중앙 스택에서 처리되거나 자동으로 생성된다. 따라서 이 코드는 YANG 데이터 모델의 의미를 구현한다.
5. **Compile Code**<br/>SIL 'src' 디렉토리에서 'make' 명령을 사용. SIL 'lib' 디렉토리에 라이브러리 파일이 생성되어야 한다. 
6. **netconfd 서버에서 사용할 수 있도록 SIL 라이브러리 설치**<br/>SIL 'src' 디렉토리에서 'make install'명령을 사용
7. **netconfd 서버 실행**
8. **새 모듈 로드**<br/>재부팅 할 때마다 모듈을 로드해야하는 경우 구성파일에 'load' 명령어 추가해야한다.
9. netconfd 서버는 지정된 YANG 모듈과 SIL을 로드하여 모든 세션에서 사용할 수 있도록 한다.

## 5.2 Server Design

![image](https://user-images.githubusercontent.com/50439622/101874479-4d3ad300-3bcc-11eb-8a21-b8bc0e7245e2.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림8. NETCONF Server 구성도

- **init:**

  init 동작에서 netconfd 서버는 ypwatcher 모니터링 프로그램을 시작하고 YANG 모듈, CLI 매개변수, 구성 파일 매개변수, 시작 장치 NETCONF 데이터베이스를 처리한 다음 NETCONF 세션을 기다린다.

- **ncxserver loop:**

  SSH2 서버는 'netconf' subsystem의 접속 연결 요청을 수신한다.<br/>새 세션 요청이 수신되면 netconf-subsystem 프로그램이 호출되어 netconfd 서버에 대한 로컬 연결을 연다.(ncxserver loop을 통해)<br/>NETCONF < rpc > 요청은 내부 NETCONF 스택에 의해 처리된다. 모듈 별 콜백 함수(파란색 상자)는 빌드 타임 또는 런타임에 시스템에 로드할 수 있다. 이것은 SIL(서버 구현 라이브러리)이라고 하는 장치 계측 코드이다. 예를 들어 libtoaster의 경우 이것은 toaster 하드웨어를 제어하는 코드이다. 

- **Cleanup:**

  \<shutdown\> 또는 \<reboot\> 작업이 호출되면 서버가 정리됨. 재부팅의 경우 프로그램을 종료하는 대신 초기화 주기가 다시 시작됨

### 5.2.1 YANG Native Operation

![image](https://user-images.githubusercontent.com/50439622/101875861-bae7fe80-3bce-11eb-9ce6-c4db32604d16.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림9. YANG model의 기본 작업

OpenYuma에서는 YANG 소스 모듈을 직접 사용하여 서버내에서 NETCONF 프로토콜 작업을 자동으로 구현한다. 모든 OpenYuma 프로그램에서 동일한 YANG parser를 사용한다. 'ncx' 소스 디렉토리(libncx.so)에 있음(OpenYuma-master/netconf/target/lib). 응용프로그램에서 설정하는 여러가지 구문분석 모드가 있다.<br/> 'server mode'에서 'description'과 'reference'와 같은 설명문은 입력 시 폐기 된다. 장치가 읽을 수 있는 명령문만 저장됨. 가능한 모든 데이터베이스 유효성 검사, 필터링, processing, 초기화, NV-storage, 오류 처리는 이러한 machine 판독 가능 문을 기반으로 수행된다. <br/>YANG 파일은 직접 또는 간접적으로 변경될 수 있으며 여기에 지정된 새로운 또는 변경된 default 값이 있다. 또한 range statement, patterns, XPath expressions, 기타 모든 기계 판독 가능 문은 자동으로 처리되므로 YANG 문 자체는 서버 소스코드와 같다.

### 5.2.2 Server Message Flows

![image](https://user-images.githubusercontent.com/50439622/102042780-10fab300-3e16-11eb-9753-fd9fc2bcb192.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림10. Main Server 구성도

netconfd 서버는 다음 유형의 구성요소를 제공한다.

- NETCONF session management
- NETCONF/YANG database management
- NETCONF/YANG protocol operations
- Access control configuration and enforcement
- RPC error reporting
- Notification subscription management
- Default data retrieval processing
- Database editing
- Database validation
- Subtree and XPath retrieval filtering
- Dynamic and static capability management
- Conditional object management (if-feature, when)
- Memory management
- Logging management
- Timer services

모든 NETCONF 및 YANG 프로토콜 작업 세부사항은 netconfd 서버 내에서 자동으로 처리된다. 모든 데이터베이스 잠금 및 편집도 서버에서 처리한다. 각 서버 요청을 처리하거나 알림을 생성하기 위해 모듈별 계측 코드에 대해 처리 모델의 여러 지점에서 사용할 수 있는 콜백 함수가 있다. 'description statement' 의미 체계를 제외한 모든것이 일반적으로 처리된다.

데이터 모델 의미 체계와 관련된 서버 계측 stub 파일은 yangdump 프로그램을 사용하여 자동으로 생성된다. 개발자는 각 YANG 데이터 모델이 나타내는 네트워킹 장치 동작을 활성화하기 위해 서버 콜백함수를 채운다.

### 5.2.3 Main ncxserver Loop

![image](https://user-images.githubusercontent.com/50439622/102043453-c8dc9000-3e17-11eb-986c-64ddbff820ed.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림 11. NETCONF Server I/0 Loop 과정

ncxserver 루프는 거의 작동하지 않으며 자체 SSH 서버가 있는 임베디드 서버에서 교체되도록 설계되었다.

- 클라이언트가 SSH 세션을 시작하도록 요청하면 netconf-subsystem 프로그램의 인스턴스에 SSH 채널이 설정된다.
- netconf-subsystem 프로그램은 local socket(/tmp/ncxserver.sock)을 열고 독점 \<ncxconnect\> 메시지를 netconfd 서버로 보낸다. netconfd 서버는 선택 루프를 사용하여 이 local socket에서 수신 대기한다.(agt_ncxserver.c 에서)
- netconfd에서 유효한 \<ncxconnect\> 메시지를 받으면 새 NETCONF 세션이 생성된다.
- \<ncxconnect\> 메시지를 보낸 후 netconf-subsystem 프로그램은 'transfer mode'로 들어가서 SSH 채널의 입력을 netconfd 서버로 전달하고 netconfd 서버의 출력을 SSH로 전달한다.
- ncxserver 루프는 빠른 시간 초과와 함께 open connections에서 입력을 기다린다. 시간이 초과 될때마다 서버는 재부팅, 종료, 신호 또는 주의가 필요한 기타 이벤트가 발생했는지 확인한다.
- 처리를 위해 이벤트가 대기중인 경우 시간 초과 확인 중에 알림을 보낼 수도 있다. --max-burst 구성 매개 변수는 이 시간 초과 확인 중에 각 알림 구독에 전송되는 알림 수를 제어한다.
- 입력 \<rpc\> 메시지는 버퍼링되고 완전한 메시지가 수신되면 서버와 요청의 영향을 받는 모든 계측 모듈 콜백함수에 의해 처리된다.

### 5.2.4 SIL Callback Functions

![image](https://user-images.githubusercontent.com/50439622/102045499-91241700-3e1c-11eb-9e03-7ed987a21c48.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림 12. NETCONF Callback

- Top Level : 최상위 레벨 수신 메시지는 서버 메시지 처리 설계에 고정 배선되지 않고 등록된다. agt-ncxserver 모듈은 netconf-subsystem의 \<ncxconnect\> 메시지를 수락하고, agt_rpc 모듈은 NETCONF \<rpc\> 메시지를 수락한다. top_register_node 함수를 사용하여 서버에서 추가 메시지를 지원할 수 있다.
- 모든 RPC 작업은 서버에 의해 데이터 기반 방식으로 구현된다. 각 NETCONF 작업은 agt_ncx.c에 있는 별도의 함수로 처리된다. agt_rpc_register_method 함수를 사용하여 모든 독점 작업을 자동으로 지원할 수 있다.
  - Note : YANG 모듈이 서버에 로드되면 모듈에 정의된 모든 RPC 작업을 사용할 수 있다. SIL 코드가 없으면 더미 'no-op'기능이 된다. 이 모드는 개발중인 클라이언트 응용 프로그램에 일부 서버 시뮬레이션 기능을 제공하는데 사용할 수 있다.
- 모든 데이터베이스 작업은 특수 데이터베이스 액세스 콜백 함수를 사용하여 구조화된 방식으로 수행된다. 모든 데이터베이스 노드에 콜백 함수가 필요한 것은 아니다. 각 'step'에 대해 하나의 콜백 함수를 사용하거나 여러 단계에 동일한 함수를 사용할 수 있다. agt/agt.cb.c의 age_cb_register_callback 함수는 SIL 코드에서 NETCONF 데이터베이스 작업에 연결하는데 사용된다.

## 5.3 Programs and Libraries Needed

### 5.3.1 SIL Shared Libraries

SIL 콜백 함수는 동적으로 로드되고 **dlopen** 및 **dlsym** 라이브러리 함수를 사용하여 서버에서 액세스 하는 공유 라이브러리로 빌드된다. 사용자 콜백함수와 해당 소스 파일은 "u\_" 접두사를 사용.  YumaPro 콜백 함수 및 해당 파일은 "y\_" 접두사를 사용한다

**SIL callback 코드는 netconfd 프로세스에서 실행된다.**

다음 YANG 문은 SIL 코드에서 지원됨

- \<rpc\> statement
- \<notification\> statement
- 모든 데이터 정의문

다음 YANG 문은 SIL 번들에 내장 된 경우 SIL 코드에서 지원된다.

- 외부 모듈에 대한 \<augment\> 문

  ![image](https://user-images.githubusercontent.com/50439622/102061103-621a9f00-3e36-11eb-9b66-5ca49a276c79.png)<br/>그림 13. YANG module 파일 코드 stub 생성(그림의 netconfd-pro는 netconfd로 대체됨)

**make_sil_dir** 스크립트는 단일 YANG 모듈에 대한 .C 및 .H 파일 코드 stub을 생성하는데 사용할 수 있다. 이 스크립트 는 **yangdump-sdk** 프로그램을 사용하여 이러한 파일을 생성한다. 이 모드에서 SIL 코드는 대상 모듈의 정의에 대해서만 생성된다. 대상 모듈 (또는 다른 모듈)의 외부 기능 보강 문은 SIL 코드 생성에 영향을 주지 않는다.

단일 모듈 용 SIL 라이브러리는 **--module** 매개 변수를 사용하여 서버에 로드된다.

YANG 서브 모듈에 대해서는 SIL 라이브러리를 생성할 수 없다. **yangdump-sdk**를 사용하여 SIL 파일을 생성하는 경우 **--undified = true** 옵션을 사용하여 전체 모듈에 대한 SIL 코드를 생성한다.

### 5.3.2 SIL Library Names

SIL 라이브러리는 서버가 최소한의 구성으로 찾을 수 있도록 예측 가능한 문자열로 이름을 지정해야 한다.<br/>이름은 "lib" + < module-name > + "." + < file-ext > 이어야 한다.

- \<module-name>은 YANG 모둘의 name field 이다.

- \<file-ext\>는 공유 라이브러리 파일 확장자이다.(일반적으로 "so")

  ```
  test.yang -> test.c -> libtest.so
  ```

### 5.3.3 SIL Library Location

기본적으로 SIL 바이너리는 **/usr/lib/yuma** 디렉토리에 설치된다.

※ YUMAPRO_RUNPATH는 SIL 라이브러리 바이너리 파일의 대체 위치를 지정하는데 사용된다.

### 5.3.4 make_sil_dir

make_sil_dir 스크립트는 단일 YANG 모듈에 대한 SIL 코드 stub 파일을 생성하는데 사용해야 한다.

**--split** 매개변수는 별도의 사용자 및 시스템 코드 stub을 생성하는데도 사용된다. 코딩을 최소화 하기 위해 권장되는 방법. 결합된 SIL 코드 stub은 고도로 최적화되거나 사용자 정의된 콜백 설계에 유용할 수  있다.

스크립트는 디렉토리 하위 트리를 생성하고 Makefile과 소스파일을 채운다.

```
>make_sil_dir --split <모듈명>
```

![image](https://user-images.githubusercontent.com/50439622/102151487-5e2e6180-3eb6-11eb-883d-423f6daa4634.png)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림 14. make_sil_dir에 의한 코드 분리



### 5.3.5 Basic YANG Module Structure

![image](https://user-images.githubusercontent.com/50439622/102177751-808ca300-3ee7-11eb-9f22-259a4dd6bbce.png) <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그림 15. YANG Module의 기본 Structure

모든 Statements는 동일한 구조를 같는다.

- statement = keyword [argument] (";" / "{" *statement "}")
- any statement can terminate (";") or start a new section of sub-statements ("{" ... "}")

YANG을 사용하면 외부 statement를 정의할 수 있다.

- 모든 표준문은 접두사가 없는 키워드로 시작 - container

- 모든 외부문은 접두사가 있는 키워드로 시작 - acme:container

  접두사는 외부 문을 정의하는 "확장"문을 포함하는 모듈용 이다.

  모든 YANG tools은 지원하지 않는 외부문을 skip 해야한다.

### 5.3.6 Identifiers in YANG Modules

- Built-in definitions 

  기본 제공 키워드 및 유형 이름은 가져오지 않으며, 사용할 때 접두사는 허용되지 않는다.

  ```
  type int32;
  ```

- From the current module

  유형 이름 및 그룹화와 같은 로컬 정의는 가져오지 않으며, 현재 모듈 접두사가 허용되지만 필수는 아니다.

  ```
  type fooType; OR type foo:fooType
  ```

- From a different submodule

  include 문은 있어야 한다. 현재 모듈 접두사가 허용되지만 필수는 아니다.

  ```
  include footypes; type fooType; OR type foo:fooType
  ```

- From a different module

  고유한 접두사가 있는 import 문이 있어야 하며, 선언된 모듈 접두사는 식별자를 사용할 때 있어야 한다.

  ```
  import bartypes { prefix bar; } type bar:barType;
  ```

---



# 6. OpenYuma OpenSource Installation

Ubuntu 18.04 LTS 환경에서 테스팅함

![image](https://user-images.githubusercontent.com/50439622/102184560-fe09e080-3ef2-11eb-89c5-606bc4a8e307.png)

네트워크 -> 어댑터2 -> 호스트 전용 어댑터로 설정 (server-client 환경 구축하기 위해 local host가 아닌 ip 할당 받기 위함)

## 6.1 External Package Needed by the Server

```shell
mydir> sudo apt-get install libxml2-dev
```

일부 XML 구문 분석 기능에 필요. Linux 내에 defaumaket로 설치되어 있지만, openyuma를 빌드하려면 DEB 기반의 libxml2-dev라는 개발자 패키지가 필요함.

```shell
mydir> sudo apt-get install openssh-server
```

SSH를 통한 NETCONF 지원을 위해 netconfd 서버에 필요.
/etc/ssh/sshd_config 파일이 구성되면 SSH 서버 restart해야 netconfd 서버가 작동함.

```shell
/mydir> sudo apt-get install libcurl4-gnutls-dev
```

netconfd 서버에서 FTP 또는 TFTP URL로 \<copy-config\>를 지원하는데 필요.

## 6.2 External Packages Needed by the Client

```shell
mydir> sudo apt-get install libssh2-1-dev
```

SSH 프로토콜을 사용하여 NETCONF 서버에 연결하려면 필요.

```shell
mydir> sudo apt-get install libncurses5-dev
```

일부 터미널 지원에 필요.

```shell
mydir> sudo apt-get install zlib1g-dev
```

OpenYuma가 가져오는 다른 라이브러리에서 사용하는 데이터 압축 지원에 필요.



https://github.com/OpenClovis/OpenYuma

![image](https://user-images.githubusercontent.com/50439622/102184906-9011e900-3ef3-11eb-90e5-deb7b725d98e.png)

Download ZIP 클릭하여 파일 다운로드

![image](https://user-images.githubusercontent.com/50439622/102185336-4249b080-3ef4-11eb-8fd1-819ab7db8194.png)

OpenYuma-master.zip 파일 압축 해제

![image](https://user-images.githubusercontent.com/50439622/102185582-981e5880-3ef4-11eb-8a88-1ac2aa0905e9.png)

OpenYuma-master파일 $HOME (/home/dylee) 경로로 복사

![image](https://user-images.githubusercontent.com/50439622/102185745-e0d61180-3ef4-11eb-876e-0edcbfeb234b.png)

## 6.3 Start the netconfd server

```shell
etc/yuma/netconfd-sample.conf
```

이 파일에 구성 매개변수에 대한 모든 기본 설정이 포함되어 있다.

netconfd-sample.conf 파일 netcofd.conf 파일로 복사하여 기본 구성 매개변수 파일 생성<br/>수정할 경우는 편집기 사용하여 수정 (아래 예시에서는 emacs 사용)

```shell
mydir> sudo cp /etc/yuma/netconfd-sample.conf /etc/yuma/netconfd.conf
mydir> sudo emacs /etc/yuma/netconfd.conf
```

## 6.4 Configure SSH

서버를 사용하기 위해서는 /etc/ssh/sshd_config 파일의 수정과 netconf subsystem 파일 추가가 필요.

```shell
mydir> sudo emacs /etc/ssh/sshd_config
```

NETCONF 서버를 시작하려면 sshd 서버가 실행 중인지 확인하고 구성이 **/etc/ssh/sshd_config**에 포함되어 있는지 확인. /etc/ssh/sshd_config에 아래 3줄 추가

```
Port 22
Port 830
Subsystem netconf /usr/sbin/netconf-subsystem
```

'Port 22' 명령은 SSH 서버가  NETCONF 세션 외에도 SSH 세션을 허용하는지 확인하는데 필요

- **Installing SSH keys**

  ```
  mydir> ssh-keygen
  ```

  YumaPro SDK는 SSH 를 제공한다.

  ```
  mydir> ssh-copy-id <your_username>@<server's IP address>
  ```

  이 프로세스는 public / private key를 만든다. public key는 서버에 있어야 함.

- **Restart the SSH Server**

  ```shell
  > sudo service ssh restart
  ```

  또는

  ```shell
  > /etc/init.d/sshd restart
  ```


## 6.5 Start netconfd

OpenYuma_master 디렉토리에 README 파일 참고하여 compile

기본 compile 수행은

```
>make
>sudo make install
```



start the **netconfd** server

```shell
> netconfd --log-level=debug4 --access-control=off

또는
> /usr/sbin/netconfd --superuser=<username>
```

원하는 방식으로 수행하도록 서버를 조정하는데 사용할 수 있는 많은 매개변수가 있다.
--log-level : 가장 자세한 디버그 메시지 수준으로 서버 시작
--access-control : 서버가 수행하는 작업을 모니터링하고 액세스 제어를 비활성화(NETCONF 액세스 제어를 설정하지 않고도 YANG 데이터 조작 가능)



netconfd 프로그램은 여러가지 방법으로 호출할 수 있다.

- To get the current version and exit:

  ```
  netconfd --version
  ```

- To get program help and exit:

  ```
  netconfd --help
  netconfd --help --brief
  netconfd --help --full
  ```

- To start the server in the background, set the logging level to 'debug', and send logging messages to a log file

  ```
  netconfd --log-level=debug --log=~/mylog &
  ```

- To start the server interactively, and send all log messages to STDOUT:

  ```
  netconfd
  ```

- To start the server interactively, with a new log file:

  ```
  netconfd --log=mylogfile
  ```

- To start the server interactively, and append to an existing log file:

  ```
  netconfd --log=mylogfile --log-append
  ```

- To get parameters from a configuration file:

  ```
  netconfd --config=/etc/yumapro/netconfd.conf
  ```

## 6.6 yangcli Connect

NETCONF 서버가 실행되면 클라이언트 세션을 수락함.
netconfd를 localhost에서 대화식으로 실행하는 경우 새 터미널창을 시작하여 계속.

yangcli 프로그램은 여러가지 방법으로 호출 할 수 있다.

- To start the client interactively, and send all log messages to STDOUT:

  ```
  yangcli
  ```

  만약,

  ![image](https://user-images.githubusercontent.com/50439622/102188593-d6b61200-3ef8-11eb-8079-fcaa63053c5b.png)

  이러한 오류 메시지 발생 시 yangcli install 해준다.

  

- To get the current version and exit:

  ```
  yangcli --version
  ```

- To get program help and exit:

  ```
  yangcli --help
  yangcli --help --brief
  yangcli --help --full
  ```

- To set the logging level to 'debug'

  ```
  yangcli --log-level=debug
  ```



각 yangcli 프로그램 인스턴스는 한번에 1개의 NETCONF 세션을 실행할 수 있다.

'connect' 명령은 NETCONF 세션을 시작하는데 사용됨. 3개의 필수 parameter가 있다.

1. user : 사용할 시스템 (또는 SSH) 사용자 이름
2. server : 사용할 NETCONF 서버의 IP 주소 또는 DNS 이름
3. password : 사용할 암호 문자열

현재 server 가 되는 가상머신의 ip주소는 192.168.56.104 이다.

![image](https://user-images.githubusercontent.com/50439622/102188755-09600a80-3ef9-11eb-8ced-7f5579c263c7.png)

```shell
> connect user=dylee server=192.168.56.104 password=dylee123
```

서버 기능 및 기타 정보를 자세히 설명하는 서버의 'hello' 메시지가 표시됨.
서버가 실행중인 터미널 창에서 서버가 시작된 디버그 수준에서 표시되는 디버그 정보를 볼 수 있다.

이제 다음과 같은 일부 명령을 실행하여 YANG 데이터를 표시할 수 있다.

![image](https://user-images.githubusercontent.com/50439622/102189243-b20e6a00-3ef9-11eb-8964-50355678c393.png)

yangcli 및 사용 가능한 명령에 대한 자세한 내용 : https://www.yumaworks.com/pub/docs/latest/pdf/yumapro-yangcli-manual.pdf

yangcli 종료하려면 'quit' 명령어 사용

```
dylee@localhost> quit
```

NETCONF seesion을 종료하려면

```
dylee@localhost> close-session
```

NETCONF 서버를 종료하려면 < Ctrl > + c

