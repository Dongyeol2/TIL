# C 기본

## 파일 입출력

- 파일 입출력을 사용하기 위한 가장 기본적인 부분\

  1. 처리할 파일을 가리키고 있을 **파일포인터(FILE *)**
  2. 해당 파일을 여는데 사용하는 **fopen(경로와 파일명, 모드)**
  3. 파일을 닫는데 사용하는 **fclose(파일 포인터)**
  4. 파일에 출력하는 **fprintf, fputs**
  5. 파일에서 입력을 받아올 수 있는 **fscanf**

  ```c
  //example
  FILE *fp
  
  fp = fopen("c\\tempFIO\\exampleFile.txt", "wt");
  //c:\tempFIO라는 파일 경로에 있는 exampleFile.txt라는 파일을 wt권한(모드)로 열겠다는 의미이다. 그걸 열어서 fp가 그 위치를 기억하고 있게 해주는 것.
  if (fp == NULL) {
      printf("실패 - 종료\n");
      return 1;
  } //예외 검사. 파일이 정상적으로 열렸다면 파일포인터에 그 값이 들어옴. 여기에 들어오지 않고 NULL값이 있다면 이것은 앞으로 파일포인터를 이용한 작업이 불가능한 상황.
  fprintf(fp, "Example. "); //파일에 print를 해줌(Example 이라는 글자 출력)
  // 첫번째 인자는 파일포인터, 두번째 인자는 문자열
  
  fclose(fp); //파일에 대한 작업이 끝났으면 해당 파일 포인터를 이용한여 그 파일을 닫아줌
  
  printf("완료\n");
  return 0;
  ```

  **첫번째 인자 값은 파일이 있는 경로와 파일 이름** 여기서 ```\\```를 사용하는 이유는 `\`가 예약된 문자라 그냥 사용이 불가능하여 `\\`로 사용이 된 것이다. (`\n` `\t` `\"` `\'` 같은 이유)

  여기서 중요한 부분 중 하나가 **권한(모드) 부분**이다.
  **fopen의 두 번째 인자 값**
  모드는 r,w,a,rt,wt,at가 있지만, 우리는 **일반적으로 wt(fprintf), rt(fscanf)**를 사용한다.
  **r** : 파일 읽기
  **w** : 파일 쓰기
  **a** : w의 확장판으로 지정한 파일이 존재하면 해당 파일 내용 끝부터 데이터를 추가
  **rt** : 파일을 읽고 쓰기, 존재하지 않는 경우 새로운 파일 생성, 존재하는 경우 데이터 추가 입력 시 원래 파일에 덮어씌워짐.
  **wt** : rt와 비슷하지만 파일이 존재하는 경우 모든 데이터를 지우고 데이터 기록
  **at** : rt와 비슷하지만 a와 마찬가지로 끝에서부터 파일 내용 끝부터 데이터를 추가

## 데이터 로드

FILE 구조체는 스트림의 상테에 대한 정보를 저장하고, 파일 함수에서 사용한다. FILE 구조체는 stdio.h 헤더 파일에 정의된 typedef 이름이다.

```c
FILE *fp
```

이러한 파일 구조체의 포인터 변수를 선언한다. 이 구조가 어떻게 선언되어 있는지 개발자가 신경 쓸 필요는 없다. 이 구조체를 이용하는 것은 표준 함수이고, 개발자가 멤버를 호출하는 것은 아니기 때문이다. 파일을 열려면 fopen() 함수를 사용한다. 표준 라이브러리 파일 관련 함수는 접두사 f로 시작하는 명명 규칙이 마련되어 있다.

### fopen() 함수

```c
FILE *fopen( const char *filename, const char *mode);
```

이 함수는 FILE 구조체에 대한 포인터를 반환한다. 이렇게 FILE 구조체의 메모리를 할당하여 초기화하는 것은 fopen() 함수의 일이며, 개발자가 FILE 구조체를 초기화하는 일은 없다. 우리는 FILE 구조체에 대한 포인터를 받아서, 이를 파일로 처리만 하면 된다.

filename에는 열려는 파일 이름을 지정한다. 파일 이름만의 경우는 기본적으로 대상이 되는 작업 디렉토리(working directory)의 파일을 검색한다. 다른 디렉토리를 검색 할 경우, 시스템 고유의 방법으로 디렉토리를 지정한다.

mode에는 파일을 열 때에 읽기 전용, 쓰기 전용, 또는 모두의 액세스 모드를 문자열로 지정한다. ASCII 문자로 문자 변환(개행 코드)하는 텍스트 파일과 변환이 되지 않는 이진 파일의 선택 등을 지정할 수 있다. 바이너리 파일에 대해서는 "바이너리 파일"에서 설명한다.

### fclose() 함수

```c
int fclose( FILE *stream);;
```

stream에는 닫기 스트림을 지정한다. 이는 fopen() 함수에서 취득한 유효한 FILE 구조체에 대한 포인터이어야 한다. 또한 fclose() 함수에는 버퍼를 플래시 하는 역할도 한다.

많은 파일 시스템은 데이터의 쓰기는 느리다. 디스크 파일 및 메모리의 큰 차이 중 하나에 액세스 속도의 격차가 있고, 디스크 액세스는 메모리 액세스보다 훨씬 느리다. 따라서 데이터를 쓸 때는 쓰기가 끝날 때까지 프로그램은 처리를 중지하고 기다려야 할 필요가 있다. 이를 효율적으로 하기 위해 파일 시스템은 일정한 데이터 양이 모이기까지는 디스크에 기록하고, 버퍼라고 하는 일시적인 저장 영역에 데이터를 대기시킨다. 버퍼에 남아있는 데이터를 쓰는 작업을 "버퍼를 플래시 한다"고 한다.

### fflush() 함수

```c
int fflush( FILE *stram);
```

stram에는 플래시하는 대상의 스트림을 지정한다. 이 함수를 호출하면, 지금까지의 파일 조작이 이행되는 것을 보장된다. 스트림이 입력용으로 열려있는 경우는 버퍼의 내용을 지운다. 또한 NULL을 전달하면 출력용으로 열려있는 모든 스트림을 플래시한다.

### fgetc() 함수

```c
int getc( FILE *stream);
```

이 함수는 지정된 스트림의 다음 문자를 int 형으로 반환한다. 정확하게는 unsigned char 형으로 읽은 문자를 int로 캐스팅하여 반환한다. 스트림은 이 같은 파일 조작 함수를 사용하면 데이터의 읽고 쓰기의 대상이 되는 파일 위치를 자동으로 이동한다.

오류가 발생하거나 파일의 마지막에 이르렀을 경우 EOF를 반환한다. EOF는 매크로로 정의되어 있으며 보통 -1의 값이다. EOF는 End Of File의 약자이다. fgetc() 함수가 돌려주는 것은 int 형이지만, 하위 8바이트는 파일에서 로드된 내용이므로 char 형에 캐스트하여 이용할 수 있다.

### feof() 함수

```c
int feof( FILE *stream);
```

stream에는 유효한 FILE 구조체에 대한 포인터를 지정한다. 지정된 스트림의 위치가 EOF라면 0이 아닌 값을 반환하고 그렇지 않으면 0을 반환한다.
또한 에러를 확인하려면 ferror() 함수를 사용한다.

### ferror() 함수

```c
int ferror(FILE *stream );
```

stream에는 유효한 FILE 구조체에 대한 포인터를 지정한다. 이 함수는 스트림에서 에러가 발생하면 0이 아닌 값을 반환하고 그렇지 않으면 0을 반환한다.

## 데이터 쓰기

데이터를 디스크에 저장하려면 파일에 기록해야 한다. 문자 데이터의 저장은 fgetc() 대센에 문자를 쓸 함수를 사용하기만하면 된다. 문자 쓰기는 fput() 함수를 사용한다.

### fputc() 함수

```c
int fputc( int c, FILE *stream );
```

c에는 기입하는 문자를, stream에 쓰기를 대상으로 하는 스트림을 지정한다. 함수가 성공하면 쓴 문자를, 실패하면 EOF를 반환한다. fputc()는 스트림의 현재 위치에 문자를 기록하여 다음 위치로 이동한다.

다만, 데이터를 쓰는 경우는 fopen() 함수의 액세스 모드가 쓰기 모드에 있어야 한다. 일반적으로 "w"를 지정하면 된다.

## 문자열의 입출력

지금까지의 파일에 대한 입출력은 문자 단위로 되어 있었다. 물론, 바이트 단위의 입출력으로 할 수 있다면 문자열의 입출력이 가능하지만, 루프를 만들고 EOF를 검출하는 등 귀찮은 프로그램을 써야한다. 이것은 비생산적이다.

텍스트 파일을 다룰 때는 문자열로 입출력을 할 수 있어야 한다. 문자열의 입출력을 할 시에는 fgets() 함수와 fputs() 함수를 사용한다. 이것들은 fgetc()와 fputc() 함수와 기본적으로 동일하지만 문자열 단위로 입출력을 할 수 있다는 점이 다르다.

### fgets() 함수

```c
char *fgets( char *string, int n, FILE *stream );
```

### fputs() 함수

```c
int fputs( const char *string, FILE *stream);
```

fgets() 함수는 string에 문자열을 포함하는 버퍼에 대한 포인터를, n에는 읽을 수 있는 최대 문자수를 지정한다. fputs()이라면 string에 쓸 문자열에 대한 포인터를 지정한다. stream에는 대상 스트림을 지정한다.

fgets() 함수는 지정된 입력 스트림 stream에서 문자열을 읽어 들여, string에 저잘한다. 문자의 해독은 현재의 스트림 위치에서 첫번째 개행 문자가 나타날지, 스트림의 끝에 도달하거나 읽은 문자가 n - 1이 되는지 조건 중에 하나가 충족 될 때까지 계속된다. 함수가 성공하면 string을 반환하고, 오류가 발생하거나 스트림의 끝에 도착한다면 NULL을 반환한다.

fputs() 함수는 성공하면 음수가 아닌 값을, 에러가 발생하면 EOF를 반환한다.